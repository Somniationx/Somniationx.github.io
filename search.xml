<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『数据结构』线性表</title>
      <link href="/2023/09/30/%E3%80%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8F%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/09/30/%E3%80%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8F%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据结构之线性表"><a href="#数据结构之线性表" class="headerlink" title="数据结构之线性表"></a>数据结构之线性表</h1><p>线性表（linear list）是n个具有相同特性的数据元素的<strong>有限</strong>序列。 线性表是一种在实际中广泛使 用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串… </p><p>线性表在<strong>逻辑结构上</strong>是线性结构，也就说是连续的一条直线。</p><p>但是在<strong>物理结构上</strong>（实际存储）并不一定是连续的， 线性表在物理上存储时，通常以<strong>数组</strong>和<strong>链式结构</strong>的形式存储</p><h2 id="一、顺序表"><a href="#一、顺序表" class="headerlink" title="一、顺序表"></a>一、顺序表</h2><p>顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。</p><p><strong>注意：</strong>此处使用数组，不能在其内部跳跃存储，需连续存储。</p><h3 id="1-1-静态顺序表"><a href="#1-1-静态顺序表" class="headerlink" title="1.1 静态顺序表"></a>1.1 静态顺序表</h3><p>静态顺序表的特点是固定长度，一旦创建后，其长度就不会改变。</p><p>优点是访问元素快速，可以通过索引直接访问元素，时间复杂度为O(1)。</p><p>缺点是插入和删除元素的操作较慢，需要进行元素的移动，时间复杂度为O(n)。</p><p><strong>注意：</strong>在使用静态顺序表时，要合理估计元素个数，避免出现溢出或浪费过多的空间。</p><h5 id="SeqList-h"><a href="#SeqList-h" class="headerlink" title="SeqList.h"></a><code>SeqList.h</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> one <span class="comment">//预处理指令，用于确保头文件在编译过程中只被包含一次，防止重复定义和潜在的编译错误</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>; <span class="comment">//声明一个编译时常量用于确定数组长度</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SqDataType;<span class="comment">//便于对数据类型的更改（后续可使用模板优化）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SqDataType _data[MAX_SIZE];<span class="comment">//静态数组</span></span><br><span class="line">   <span class="type">size_t</span> _size;<span class="comment">//数据元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>此处仅对静态顺序表进行定义不进行实现，因为较为简单且使用频率低。</p><h3 id="1-2-动态顺序表"><a href="#1-2-动态顺序表" class="headerlink" title="1.2 动态顺序表"></a>1.2 动态顺序表</h3><p>与静态顺序表不同，动态顺序表的长度可以在运行时动态地进行调整，以适应元素的插入、删除等操作。</p><p>在动态顺序表中，通常使用动态内存分配来管理顺序表的存储空间。</p><h4 id="1-2-1-主要特点"><a href="#1-2-1-主要特点" class="headerlink" title="1.2.1 主要特点"></a>1.2.1 <strong>主要特点</strong></h4><ol><li>可变长度：动态顺序表的长度可以根据需要进行动态扩展或收缩。当元素数量超过当前容量时，可以自动扩展内存以容纳更多元素。</li><li>动态内存管理：使用动态内存分配来动态管理顺序表的存储空间。通过申请和释放内存，动态顺序表可以根据需求调整容量。</li><li>灵活性：由于长度可变，动态顺序表可以灵活地进行插入、删除和修改等操作，而不需要移动其他元素。</li></ol><h4 id="1-2-2-主要操作"><a href="#1-2-2-主要操作" class="headerlink" title="1.2.2 主要操作"></a>1.2.2 主要操作</h4><ol><li>创建顺序表：动态分配一定的内存空间，并初始化顺序表的相关属性。</li><li>插入元素：在指定位置插入一个元素，如果当前容量不足，需要扩展内存空间。</li><li>删除元素：删除指定位置的元素，如果删除后容量过大，可以收缩内存空间。</li><li>查找元素：按照索引位置或元素值进行查找，并返回对应的元素。</li><li>修改元素：根据索引位置或元素值，修改指定位置的元素值。</li><li>获取长度：返回顺序表中元素的个数。</li><li>遍历顺序表：按照顺序输出顺序表中的所有元素。</li></ol><h4 id="1-2-3-代码实现"><a href="#1-2-3-代码实现" class="headerlink" title="1.2.3 代码实现"></a>1.2.3 <strong>代码实现</strong></h4><h5 id="SeqList-h-1"><a href="#SeqList-h-1" class="headerlink" title="SeqList.h"></a><code>SeqList.h</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> one</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SqDataType;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SqDataType* _array;  <span class="comment">// 存储数据的数组指针</span></span><br><span class="line">    <span class="type">size_t</span> _size;    <span class="comment">// 当前元素个数</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;  <span class="comment">// 当前容量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SqList</span>();<span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">SqList</span>();<span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkCapacity</span><span class="params">()</span></span>;<span class="comment">//检查容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(SqDataType value)</span></span>;<span class="comment">//尾部插入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(SqDataType value)</span></span>;<span class="comment">//头部插入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;<span class="comment">//尾部删除</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;<span class="comment">//头部删除</span></span><br><span class="line">    <span class="function">SqDataType <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span></span>; <span class="comment">//按索引位置查找</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span></span>;<span class="comment">//获取长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//遍历顺序表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SeqList-cpp"><a href="#SeqList-cpp" class="headerlink" title="SeqList.cpp"></a><code>SeqList.cpp</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;SeqList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SeqList::<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line">        _array = <span class="literal">nullptr</span>;<span class="comment">//对成员属性进行初始化</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">        _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SeqList::~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_array != <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">delete</span>[] _array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于头插尾插都需要检查容量，便提取出此函数用于检查容量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对初次插入和后续插入进行扩容处理</span></span><br><span class="line">    <span class="comment">//因为初次进入_size和_capacity都为0，判断为满，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (_size == _capacity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_capacity == <span class="number">0</span>)</span><br><span class="line">            _capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _capacity *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开辟新空间并进行数据移动</span></span><br><span class="line">        <span class="type">int</span>* newArray = <span class="keyword">new</span> SqDataType[_capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">            newArray[i] = _array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将旧空间进行释放，避免内存泄漏</span></span><br><span class="line">        <span class="keyword">delete</span>[] _array;</span><br><span class="line">        _array = newArray;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾部插入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="built_in">checkCapacity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处使用_size++需要读者结合数组下标特性进行理解</span></span><br><span class="line">    _array[_size++] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾部删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//只有在有容量的情况下才能进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (_size &gt; <span class="number">0</span>)</span><br><span class="line">        _size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头部插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(SqDataType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">checkCapacity</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在头部插入数据需要将后续数据全部向后挪动</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> index = size; index &gt; <span class="number">0</span>; index--)</span><br><span class="line">    _array[index] = _array[index - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//挪动数据后将数据插入头部更新size</span></span><br><span class="line">    _array[<span class="number">0</span>] = value;</span><br><span class="line">    _size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头部删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_size != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> index = <span class="number">0</span>; index &lt; _size - <span class="number">1</span>; index++)</span><br><span class="line">            _array[index] = _array[index + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按索引查找</span></span><br><span class="line"><span class="function">SqDataType <span class="title">get</span><span class="params">(<span class="type">size_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; _size)</span><br><span class="line">        <span class="keyword">return</span> _array[index];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取容量</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//便利打印顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> index = <span class="number">0</span>; index &lt; _size; index++)</span><br><span class="line">        std::cout &lt;&lt; _array[index] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Linux』环境变量</title>
      <link href="/2023/09/26/%E3%80%8ELinux%E3%80%8F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2023/09/26/%E3%80%8ELinux%E3%80%8F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h2 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h2><blockquote><p>在Linux操作系统中，环境变量是一种关键的配置机制，用于存储和传递有关系统和应用程序的信息。它们是以键值对的形式存在的，其中键是环境变量的名称，值是与之相关联的数据。环境变量可以在各种系统级和用户级任务中使用，其主要目的是自定义和配置系统行为以及影响应用程序和进程的运行方式。</p></blockquote><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p>当谈到Linux环境变量时，有很多方面需要考虑。以下是更详细的介绍：</p><h3 id="环境变量的分类"><a href="#环境变量的分类" class="headerlink" title="环境变量的分类"></a><strong>环境变量的分类</strong></h3><ul><li><p><strong>用户级环境变量</strong>：每个用户都可以定义和使用的变量，通常存储在用户的主目录中的<code>.bashrc</code>或<code>.bash_profile</code>文件中。这些变量仅在用户的Shell会话中可见。</p></li><li><p><strong>系统级环境变量</strong>：对整个系统中的所有用户都可见的变量。通常存储在系统范围的配置文件中，例如<code>/etc/environment</code>、<code>/etc/profile</code>或<code>/etc/bash.bashrc</code>。这些变量可以影响系统的整体行为。</p></li></ul><h3 id="常见的环境变量"><a href="#常见的环境变量" class="headerlink" title="常见的环境变量"></a><strong>常见的环境变量</strong></h3><ul><li><p><strong>PATH</strong>：包含一组目录路径，用于告诉Shell在哪里查找可执行文件。当您在终端中输入一个命令时，Shell会在<code>PATH</code>中列出的目录中查找该命令的可执行文件。</p></li><li><p><strong>HOME</strong>：表示当前用户的主目录的路径。通常用于指示应用程序将配置文件和数据保存在用户的主目录中。</p></li><li><p><strong>USER</strong>：当前登录用户的用户名。</p></li><li><p><strong>LANG</strong>和<code>LC_*</code>：用于设置系统的语言环境和区域设置。这些变量影响文本编码、日期格式、货币符号等。</p></li><li><p><strong>PWD</strong>：表示当前工作目录的路径。这个变量会随着您在文件系统中切换目录而变化。</p></li><li><p><strong>SHELL</strong>：指示当前用户使用的默认Shell的路径。</p></li></ul><h3 id="设置和导出环境变量"><a href="#设置和导出环境变量" class="headerlink" title="设置和导出环境变量"></a><strong>设置和导出环境变量</strong></h3><ul><li><p>要设置一个环境变量，可以使用<code>VARIABLE_NAME=value</code>的语法。例如：<code>MY_VARIABLE=&quot;some_value&quot;</code>。</p></li><li><p>要使环境变量在<strong>当前Shell会话中可见</strong>，需要使用<code>export</code>命令：<code>export MY_VARIABLE</code>。</p></li><li><p>若要永久保存环境变量，通常需要将其添加到Shell的配置文件中。用户级变量添加到<code>~/.bashrc</code>或<code>~/.bash_profile</code>，系统级变量添加到<code>/etc/environment</code>等文件中。</p></li></ul><h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a><strong>查看环境变量</strong></h3><ul><li><p>使用<code>env</code>命令可以列出当前Shell中定义的所有环境变量，以及它们的值。</p></li><li><p>使用<code>echo $VARIABLE_NAME</code>可以查看特定环境变量的值。例如，<code>echo $PATH</code>将显示<code>PATH</code>环境变量的值。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Somn@VM-16-4-centos ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/Somn/.local/bin:/home/Somn/bin</span><br><span class="line">[Somn@VM-16-4-centos ~]$ <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/home/Somn</span><br><span class="line">[Somn@VM-16-4-centos ~]$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h3 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a><strong>删除环境变量</strong></h3><ul><li>要删除一个特定的环境变量，可以使用<code>unset VARIABLE_NAME</code>命令。例如：<code>unset MY_VARIABLE</code>。</li></ul><h3 id="环境变量的作用"><a href="#环境变量的作用" class="headerlink" title="环境变量的作用"></a><strong>环境变量的作用</strong></h3><ul><li><p>环境变量在各种情况下非常有用，例如在脚本中存储配置信息、指定默认编辑器、设置语言首选项等。</p></li><li><p>它们还用于控制系统行为，例如<strong>通过<code>PATH</code>来指定可执行文件的搜索路径</strong>。</p></li><li><p>环境变量还可用于将信息从一个Shell会话传递到另一个Shell会话。</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><ul><li><p>设置<code>JAVA_HOME</code>环境变量，以指定Java的安装路径：<code>export JAVA_HOME=/usr/java/jdk1.8.0_291</code></p></li><li><p>将新的目录添加到<code>PATH</code>环境变量，以使Shell能够找到新的可执行文件：<code>export PATH=$PATH:/path/to/new/directory</code></p></li><li><p>在Shell脚本中使用环境变量来引用配置信息，例如数据库连接字符串或API密钥。</p></li></ul><blockquote><p>总之，Linux环境变量是配置和自定义Linux系统行为的重要工具。了解如何设置、使用和管理这些变量对于在Linux环境中工作和管理系统非常重要。</p></blockquote><h2 id="测试PATH"><a href="#测试PATH" class="headerlink" title="测试PATH"></a>测试PATH</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;To test env!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Somn@VM-16-4-centos environment]$ gcc -o testEnv testEnv.c </span><br><span class="line">[Somn@VM-16-4-centos environment]$ ./testEnv </span><br><span class="line">To <span class="built_in">test</span> <span class="built_in">env</span>!</span><br><span class="line">[Somn@VM-16-4-centos environment]$ testEnv</span><br><span class="line">-bash: testEnv: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p><strong>为什么有些指令可以直接执行，而我们的二进制程序需要带路径才能执行？</strong></p><p>这涉及到Linux系统的<strong>执行文件搜索路径</strong>。当您在终端中输入一个命令时，系统会在一组<strong>预定义的目录中</strong>搜索该命令的<strong>可执行文件</strong>。这些目录包括<code>/bin</code>、<code>/usr/bin</code>、<code>/usr/local/bin</code>等（PATH）。如果您在一个可执行文件的<strong>绝对路径</strong>中运行它（例如<code>./hello</code>），那么系统会直接运行该文件。如果您不带路径运行一个命令，系统会按照<code>$PATH</code>环境变量中定义的路径顺序来搜索命令。这就解释了为什么有些指令可以直接执行，因为它们的可执行文件位于系统的默认搜索路径中。</p><p><strong>将程序所在路径加入环境变量PATH中</strong></p><p>将程序所在路径添加到<code>$PATH</code>环境变量中是一种常见的方法，可以让您的二进制程序在不带路径的情况下直接执行。通过执行以下命令，您可以将程序所在路径添加到<code>$PATH</code>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/path/to/hello_program</span><br></pre></td></tr></table></figure><p>在这里，<code>/path/to/hello_program</code>应替换为<code>hello</code>程序所在的实际路径。一旦将路径添加到<code>$PATH</code>中，您就可以在任何位置直接运行<code>hello</code>程序，而无需提供完整的路径。</p><p><strong>对比测试</strong></p><p>在将程序所在路径添加到<code>$PATH</code>后，您可以进行对比测试。首先，确保环境变量已经更新，可以使用<code>echo $PATH</code>来验证。然后，尝试在不同的目录中运行<code>hello</code>程序，您会发现它可以直接执行而无需提供路径。</p><p><strong>修改之前提供的实例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Somn@VM-16-4-centos environment]$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/Somn/environment/</span><br><span class="line">[Somn@VM-16-4-centos environment]$ testEnv </span><br><span class="line">To <span class="built_in">test</span> <span class="built_in">env</span>!</span><br><span class="line">[Somn@VM-16-4-centos environment]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/Somn/.local/bin:/home/Somn/bin:/home/Somn/environment/</span><br><span class="line">[Somn@VM-16-4-centos environment]$ <span class="built_in">cd</span> ..</span><br><span class="line">[Somn@VM-16-4-centos ~]$ testEnv</span><br><span class="line">To <span class="built_in">test</span> <span class="built_in">env</span>!</span><br></pre></td></tr></table></figure><p>可以在<strong>任何位置</strong>直接运行<code>testEnv</code>程序，无需提供完整的路径。</p><p><strong>其他方法</strong></p><p>除了将程序路径添加到<code>$PATH</code>中之外，还有其他方法可以实现不带路径直接运行程序：</p><ul><li><strong>使用符号链接</strong>：您可以创建一个符号链接（软链接），将它放在一个在<code>$PATH</code>中的目录下，使它指向实际的可执行文件。这样，您可以通过符号链接的名称来运行程序，而不必提供完整路径。</li></ul><p>以下是一个创建符号链接的示例：</p><p>假设您有一个可执行文件 <code>my_program</code>，其完整路径为 <code>/path/to/my_program</code>，而且您想要使它可以在任何目录中直接运行。您可以按照以下步骤创建符号链接：</p><ol><li><p>使用 <code>ln -s</code> 命令创建符号链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /path/to/my_program /usr/local/bin/my_program</span><br></pre></td></tr></table></figure><p>这将创建一个名为 <code>my_program</code> 的符号链接文件，它位于 <code>/usr/local/bin/</code> 目录中，并指向 <code>/path/to/my_program</code>。</p></li><li><p>确保 <code>/usr/local/bin/</code> 在 <code>$PATH</code> 中：</p><p>通常情况下，<code>/usr/local/bin/</code> 是在 <code>$PATH</code> 中的，但您可以通过运行 <code>echo $PATH</code> 来验证。如果没有包含 <code>/usr/local/bin/</code>，可以通过将它添加到 <code>$PATH</code> 来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/bin</span><br></pre></td></tr></table></figure><p><strong>请注意，这只会在当前会话中使其生效。</strong>如果要<strong>永久</strong>更改 <code>$PATH</code>，需要将上述命令添加到您的 Shell 配置文件中，如 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code>。</p></li><li><p>现在，您可以在任何目录中通过 <code>my_program</code> 来运行程序，而不必提供完整路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_program</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这样，您创建了一个<strong>全局可用的符号链接</strong>，使您的程序可以在不同的目录中直接运行，而不需要提供完整路径。这对于将常用工具变成全局可用的命令非常有用，提高了系统的可用性和易用性。</p></blockquote><ul><li><p><strong>将可执行文件移动到<code>/usr/local/bin</code>等目录</strong>：如果您有权限，可以将可执行文件移到系统的标准可执行文件目录之一，如<code>/usr/local/bin</code>。这样，它就可以直接执行了。</p></li><li><p><strong>使用绝对路径别名</strong>：在某些情况下，您可以通过在Shell配置文件中创建别名来实现直接运行程序。例如，在<code>~/.bashrc</code>中添加别名：<code>alias myapp=&quot;/path/to/hello_program&quot;</code>。这样，您可以运行<code>myapp</code>而不需要提供完整路径。</p></li></ul><blockquote><p>总之，Linux中有多种方法可以实现不带路径直接运行程序，其中将程序所在路径添加到<code>$PATH</code>是最常见的方法之一，它可以方便地使程序全局可用。其他方法可以根据特定需求来选择。</p></blockquote><h2 id="测试HOME"><a href="#测试HOME" class="headerlink" title="测试HOME"></a>测试HOME</h2><p><code>HOME</code> 是一个环境变量，用于表示当前用户的主目录路径。在Linux中，不同用户的主目录通常是不同的。下面我们来对比 root 用户和普通用户在使用 <code>echo $HOME</code> 和 <code>cd ~; pwd</code> 时的差异。</p><ol><li><p><strong>用 root 和普通用户，分别执行 <code>echo $HOME</code>，对比差异</strong>：</p><ul><li><p>当 root 用户执行 <code>echo $HOME</code> 时，它会显示 root 用户的主目录路径，通常是 <code>/root</code>。因为 root 用户是系统管理员，其主目录位于根目录下。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># echo $HOME</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure></li><li><p>当普通用户执行 <code>echo $HOME</code> 时，它会显示该普通用户的主目录路径，通常是 <code>/home/用户名</code>。每个普通用户都有自己的主目录。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Somn@VM-16-4-centos ~]$ <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/home/Somn</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>执行 <code>cd ~; pwd</code>，对应 <code>~</code> 和 <code>HOME</code> 的关系</strong>：</p><ul><li><p>当用户执行 <code>cd ~; pwd</code> 时，<code>~</code> 表示当前用户的<strong>主目录</strong>，等效于 <code>HOME</code> 环境变量的值。</p><p>普通用户执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Somn@VM-16-4-centos environment]$ <span class="built_in">cd</span> ~</span><br><span class="line">[Somn@VM-16-4-centos ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/Somn</span><br></pre></td></tr></table></figure><p>root用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos <span class="built_in">test</span>]<span class="comment"># cd ~</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure><p>这里 <code>cd ~</code> 让用户进入了其<strong>主目录</strong>，而 <code>pwd</code> 命令显示了当前工作目录的路径，即用户的主目录。</p></li></ul></li></ol><blockquote><p>总结：<strong><code>HOME</code> 环境变量表示用户的主目录路径，不同用户的主目录不同。</strong><code>~</code> 是一个特殊字符，表示当前用户的主目录，它与 <code>HOME</code> 的值相同。因此，<code>cd ~</code> 可以用来进入当前用户的主目录。根用户和普通用户的主目录通常是不同的，因此 <code>echo $HOME</code> 和 <code>cd ~; pwd</code> 的结果也会有所不同。</p></blockquote><h2 id="相关命令介绍"><a href="#相关命令介绍" class="headerlink" title="相关命令介绍"></a>相关命令介绍</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a><strong><code>echo</code></strong></h3><p><code>echo</code> 命令用于在终端上显示文本或环境变量的值。您可以使用 <code>echo $VARIABLE_NAME</code> 来查看特定环境变量的值。例如：<code>echo $HOME</code> 会显示主目录的路径。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a><strong><code>export</code></strong></h3><p><code>export</code> 命令用于设置一个新的环境变量，或者将一个已存在的变量升级为环境变量，使其在当前Shell会话以及其后启动的子进程中可见。例如：<code>export MY_VARIABLE=&quot;some_value&quot;</code>。</p><p>假设您希望创建一个名为 <code>MY_VARIABLE</code> 的环境变量，其值为 “some_value”。您可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> MY_VARIABLE=<span class="string">&quot;some_value&quot;</span></span><br></pre></td></tr></table></figure><p>现在，<code>MY_VARIABLE</code> 已经成为一个环境变量，并且可以在当前Shell会话中访问。您可以使用 <code>echo</code> 命令来查看它的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span></span><br><span class="line">some_value</span><br></pre></td></tr></table></figure><p>此时，您可以在<strong>当前Shell会话中</strong>使用 <code>MY_VARIABLE</code> 这个环境变量，也可以在<strong>当前Shell的任何子进程中</strong>使用它，包括<strong>从当前Shell启动的任何脚本或命令</strong>。</p><blockquote><p>总之，<code>export</code> 命令允许您创建环境变量，以便它们在当前Shell会话以及从当前Shell启动的子进程中都可见。这对于传递配置信息、设置全局变量和影响子进程的行为非常有用。</p><p><code>$ export MY_VARIABLE=&quot;some_value&quot;</code> 中的 “some_value” 不一定是路径，它可以是任何字符串，具体取决于您希望将 <code>MY_VARIABLE</code> 设置为的值。通常情况下，环境变量可以存储各种类型的数据，不仅仅是文件路径。</p></blockquote><p>例如，可以将环境变量设置为以下内容：</p><ul><li><p>一个文件路径：<code>export MY_PATH=&quot;/path/to/some/file&quot;</code></p></li><li><p>一个字符串：<code>export GREETING=&quot;Hello, World!&quot;</code></p></li><li><p>一个数字：<code>export PORT=8080</code></p></li><li><p>一个命令或脚本：<code>export SCRIPT=&quot;myscript.sh&quot;</code></p></li></ul><blockquote><p>在上述示例中，环境变量的值可以是文件路径、字符串、数字或命令名称，具体取决于您的需求和用途。环境变量的目的是在系统和应用程序中存储和传递配置信息和数据，因此可以用来表示各种不同类型的信息。</p></blockquote><h3 id="env"><a href="#env" class="headerlink" title="env"></a><strong><code>env</code></strong></h3><p><code>env</code> 命令用于显示当前Shell会话中定义的所有环境变量，以及它们的值。这个命令不仅显示用户级环境变量，还显示系统级环境变量。例如：<code>env</code> 命令会列出所有环境变量的值。</p><h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a><strong><code>unset</code></strong></h3><p><code>unset</code> 命令用于清除或删除一个特定的环境变量。例如：<code>unset MY_VARIABLE</code> 会删除名为 <code>MY_VARIABLE</code> 的环境变量。</p><p>当使用 <code>unset</code> 命令来删除一个特定的环境变量时，<strong>它将不再在当前Shell会话中有效，而且在以后的会话中也不会再显示</strong>。以下是一个使用 <code>unset</code> 删除环境变量的示例：</p><p>假设有一个名为 <code>MY_VARIABLE</code> 的环境变量，其存储了一个值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> MY_VARIABLE=<span class="string">&quot;some_value&quot;</span></span><br></pre></td></tr></table></figure><p>您可以使用 <code>echo</code> 命令来查看它的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span></span><br><span class="line">some_value</span><br></pre></td></tr></table></figure><p>然后，如果您想要删除这个环境变量，可以使用 <code>unset</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">unset</span> MY_VARIABLE</span><br></pre></td></tr></table></figure><p>现在，再次尝试使用 <code>echo</code> 命令来查看 <code>MY_VARIABLE</code> 的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MY_VARIABLE</span></span><br></pre></td></tr></table></figure><p>这时<strong>不会显示任何输出</strong>，因为 <code>MY_VARIABLE</code> 已经被成功删除，它不再存在于当前Shell会话中。<strong>如果您在以后的会话中尝试查看它，也会得到相同的结果，因为该变量已经被永久删除。</strong></p><blockquote><p>使用 <code>unset</code> 命令是一种有效地删除环境变量的方式，尤其当您不再需要某个变量或需要清除敏感信息时，这个命令非常有用。</p></blockquote><h3 id="set"><a href="#set" class="headerlink" title="set"></a><strong><code>set</code></strong></h3><p> <code>set</code> 命令用于显示当前Shell中定义的所有本地定义的Shell变量和环境变量。这包括了所有的本地变量、环境变量以及一些系统级变量。请注意，<code>set</code> 显示的内容可能非常详细，包括了大量信息，包括不仅限于环境变量。这个命令主要用于调试和查看当前Shell的状态。</p><h2 id="环境变量的组织方式"><a href="#环境变量的组织方式" class="headerlink" title="环境变量的组织方式"></a>环境变量的组织方式</h2><h3 id="组织特点"><a href="#组织特点" class="headerlink" title="组织特点"></a>组织特点</h3><blockquote><p>环境变量通常以键值对的形式组织，其中键表示变量的名称，而值表示变量的内容。这种组织方式使得环境变量易于管理和访问。以下是环境变量的组织方式的一些常见特点：</p></blockquote><ol><li><p><strong>键值对结构</strong>：每个环境变量都有一个唯一的键（变量名）和一个与之关联的值。这种结构允许您使用变量名来引用和访问特定的环境变量。</p></li><li><p><strong>大小写敏感</strong>：在大多数Unix和Linux系统中，环境变量的名称通常是大小写敏感的，这意味着<code>MY_VARIABLE</code>和<code>my_variable</code>被视为不同的变量。</p></li><li><p><strong>通常使用大写字母</strong>：约定俗成的做法是将环境变量的名称表示为大写字母，以便与普通变量区分开来，例如<code>PATH</code>、<code>HOME</code>等。这不是强制性的，但是有助于提高可读性和可维护性。</p></li><li><p><strong>特殊字符</strong>：环境变量的名称通常只包含字母、数字和下划线字符（<code>_</code>）。变量值可以包含各种字符，包括特殊字符，但可能需要适当地进行转义或引用。</p></li><li><p><strong>键值对分隔符</strong>：通常，键和值之间用等号（<code>=</code>）分隔。例如：<code>MY_VARIABLE=&quot;some_value&quot;</code>。</p></li><li><p><strong>多个环境变量</strong>：您可以定义和管理多个环境变量，每个变量都有一个唯一的名称，以存储不同类型的配置信息和数据。</p></li><li><p><strong>系统级和用户级环境变量</strong>：在Linux系统中，有些环境变量是全局的，系统中的所有用户都可以访问，而有些是用户级的，只能由特定用户访问。系统级环境变量通常位于<code>/etc/environment</code>等系统级配置文件中，而用户级环境变量位于<code>~/.bashrc</code>、<code>~/.bash_profile</code>或类似的用户级配置文件中。</p></li><li><p><strong>导出和非导出</strong>：只有通过<code>export</code>命令设置的环境变量才会被传递给子进程。未使用<code>export</code>的变量通常是本地变量，仅在当前Shell会话中可见。</p></li></ol><h3 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h3><p>当一个程序在Linux或类Unix系统中启动时，操作系统会自动为该程序创建一个环境表（environment table）。这个环境表是一个字符指针数组，其中每个指针指向一个以null终止字符（’\0’）结尾的环境字符串，这些字符串包含了程序运行时所需的环境变量。</p><p>这个环境表通常存储在程序的内存空间中，并且在程序运行期间可供程序访问。环境表中的环境变量以键值对的形式存储，其中键和值都是以字符串的形式表示，并由等号（’=’）分隔。</p><p>以下是一个示例环境表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *envp[] = &#123;</span><br><span class="line">    <span class="string">&quot;PATH=/usr/bin:/bin&quot;</span>,  <span class="comment">// 环境变量PATH的值</span></span><br><span class="line">    <span class="string">&quot;HOME=/home/user&quot;</span>,     <span class="comment">// 环境变量HOME的值</span></span><br><span class="line">    <span class="string">&quot;LANG=en_US.UTF-8&quot;</span>,    <span class="comment">// 环境变量LANG的值</span></span><br><span class="line">    <span class="literal">NULL</span>                    <span class="comment">// 环境表以NULL指针结束</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>envp</code> 是一个<strong>指向环境表的指针</strong>，它包含了三个环境变量。每个环境变量都由一个字符串表示，其中包括了环境变量的名称和值，以等号分隔。<strong>最后，环境表以一个NULL指针结束，以指示表的末尾。</strong></p><p>在程序运行期间，程序可以使用标准的C库函数来访问这些环境变量的值，例如<code>getenv</code>函数。例如，要获取<code>PATH</code>环境变量的值，程序可以使用以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *path = getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PATH: %s\n&quot;</span>, path);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PATH environment variable not found.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序还可以通过修改环境表来改变环境变量的值，但这<strong>通常不是一种推荐的做法</strong>，因为它可能会<strong>导致不可预测的行为</strong>，特别是对于其他正在运行的程序。</p><blockquote><p>总之，环境表是一个存储环境变量的数据结构，用于向运行的程序提供配置信息和运行时参数。环境变量以键值对的形式存储在环境表中，并可以通过程序来访问和使用。这是Unix和Linux系统中一个重要的机制，用于自定义和配置程序的行为。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『LeetCode』只出现一次的数字</title>
      <link href="/2023/09/26/%E3%80%8ELeetCode%E3%80%8FLeetCode136/"/>
      <url>/2023/09/26/%E3%80%8ELeetCode%E3%80%8FLeetCode136/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h1><p>给定一个非空整数数组 <code>nums</code>，除了某个元素只出现一次以外，其余每个元素均出现两次。</p><p><strong>你需要设计并实现一个线性时间复杂度的算法来解决此问题，并且该算法只能使用常量额外空间。</strong></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h2><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[2, 2, 1]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[4, 1, 2, 1, 2]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[1]</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a><strong>提示</strong></h2><ul><li>数组长度范围：<code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li><li>数组元素范围：<code>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</code></li><li><strong>除了某个元素只出现一次以外，其余每个元素均出现两次。</strong></li></ul><h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><blockquote><p>异或运算（XOR，也称为按位异或运算）是一种二进制位运算，它在计算机科学中非常重要。异或运算的操作规则非常简单：<strong>对于两个二进制位，如果它们相同则结果为0，如果它们不同则结果为1。</strong></p></blockquote><h3 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h3><p>异或运算通常用符号 “⊕” 或者 “^” 表示。在许多编程语言中，用符号 “^” 来表示异或运算。例如，在C++中，你可以使用 <code>^</code> 运算符来执行异或运算。</p><h3 id="运算性质"><a href="#运算性质" class="headerlink" title="运算性质"></a>运算性质</h3><ol><li><strong>交换律</strong>：对于任何整数 a 和 b，a ⊕ b 等于 b ⊕ a。也就是说，异或运算是可交换的。</li><li><strong>结合律</strong>：对于任何整数 a、b 和 c，(a ⊕ b) ⊕ c 等于 a ⊕ (b ⊕ c)。也就是说，异或运算是可结合的。</li><li><strong>自反性</strong>：对于任何整数 a，a ⊕ a 等于 0。也就是说，一个数与自己做异或运算的结果是0。</li><li><strong>零元素</strong>：对于任何整数 a，a ⊕ 0 等于 a。也就是说，一个数与0做异或运算的结果是它本身。</li></ol><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p>假设我们要计算 5 ⊕ 3：</p><ol><li>首先，将这两个数表示为二进制形式：<ul><li>5 的二进制表示是：<code>101</code></li><li>3 的二进制表示是：<code>011</code></li></ul></li><li>然后，从右向左按位进行异或运算。在每个位置上，如果两个对应的位相同（都是1或都是0），结果就是0；如果两个对应的位不同，结果就是1。<ul><li>第一个位：1 ⊕ 1 = 0</li><li>第二个位：0 ⊕ 1 = 1</li><li>第三个位：1 ⊕ 0 = 1</li></ul></li><li>将结果组合起来，得到最终的二进制表示：<code>110</code>。</li><li>最后，将二进制结果转换回十进制，得到最终结果：<code>6</code>。</li></ol><p>所以，5 ⊕ 3 的计算结果是 <code>6</code>。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><strong>交换变量的值</strong>：可以使用异或运算来交换两个变量的值而不需要额外的临时变量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">7</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line"><span class="comment">// 现在 a = 7，b = 5</span></span><br></pre></td></tr></table></figure><ul><li><strong>检查奇偶性</strong>：通过将一个整数与1进行异或运算，可以快速确定该整数是奇数还是偶数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span> (num &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// num 是奇数</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// num 是偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>数据加密</strong>：异或运算在数据加密和解密中有广泛应用。</li></ul><p>假设我们有一个简单的加密算法，其中我们将明文（原始文本）与一个密钥进行异或运算以生成密文（加密文本）。解密时，只需再次对密文与相同的密钥进行异或运算，就可以还原明文。</p><p>例如，我们使用密钥 <code>1010</code> 对明文 <code>1100</code> 进行加密：</p><ul><li>明文 <code>1100</code></li><li>密钥 <code>1010</code></li><li>密文 <code>0110</code></li></ul><p>解密时，我们再次对密文 <code>0110</code> 与相同的密钥 <code>1010</code> 进行异或运算：</p><ul><li>密文 <code>0110</code></li><li>密钥 <code>1010</code></li><li>明文 <code>1100</code></li></ul><h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h2><blockquote><p>当一个整数数组中只有一个元素出现一次，而其他所有元素都出现两次时，可以使用<strong>异或运算</strong>来解决这个问题。<strong>异或运算有一个有用的性质，即任何数与自己做异或运算的结果都是0，而任何数与0做异或运算的结果都是它本身。</strong>因此，如果我们将数组中的所有元素进行异或运算，成对出现的元素会<strong>相互抵消</strong>，最终剩下的就是只出现一次的元素。</p></blockquote><ol><li><p>初始化一个变量 <code>result</code> 为0，用来存储最终的结果。</p></li><li><p>遍历整个数组 <code>nums</code>，对每个元素进行异或运算，将结果存储在 <code>result</code> 中。由于异或运算满足交换律和结合律，相同的元素都会相互抵消，最终 <code>result</code> 中将只包含出现一次的元素。</p></li><li><p>返回 <code>result</code>，它就是只出现一次的元素。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        result ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">singleNumber</span>(nums);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The single number is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。令 a_1、a_2、…、a_m 为出现两次的 m 个数，a_m+1 为出现一次的数。根据异或运算的性质，<strong>数组中的全部元素的异或运算结果</strong>总是可以写成如下形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a_1 ⊕ a_1) ⊕ (a_2 ⊕ a_2) ⊕ ⋯ ⊕ (a_m ⊕ a_m) ⊕ a_m+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>根据异或运算的性质，上式可化简和计算得到如下结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ⊕ <span class="number">0</span> ⊕ ⋯ ⊕ <span class="number">0</span> ⊕ a_m+<span class="number">1</span> = a_m+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p><blockquote><p>此代码会找出数组中只出现一次的元素并打印出来。你可以根据自己的需要替换<code>nums</code>数组来测试不同的输入。</p><p>这个算法的<strong>时间复杂度为 O(n)</strong>，其中 n 是数组的长度，因为它只需要遍历一次数组。而且它只使用了<strong>常量额外的空间</strong>，满足了题目的要求。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Linux』冯诺依曼体系结构</title>
      <link href="/2023/09/22/%E3%80%8ELinux%E3%80%8F%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/09/22/%E3%80%8ELinux%E3%80%8F%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h3><blockquote><p>冯·诺依曼体系结构（Von Neumann architecture）是计算机科学和计算机工程领域中的一个基本概念，它是现代计算机体系结构的基础。这个体系结构是由匈牙利裔美国数学家和计算机科学家<strong>约翰·冯·诺伊曼（John Von Neumann）</strong>于20世纪40年代提出的，被广泛认为是现代计算机的基础设计原则之一。</p></blockquote><h4 id="关键特征和组成部分"><a href="#关键特征和组成部分" class="headerlink" title="关键特征和组成部分"></a>关键特征和组成部分</h4><blockquote><ol><li><strong>存储程序：</strong>在冯·诺伊曼体系结构中，程序和数据都以二进制形式存储在存储器中。这意味着计算机可以通过读取存储器中的指令来执行程序，使其具有通用性。</li><li><strong>中央处理器（CPU）：</strong>CPU 是计算机的大脑，负责执行存储在存储器中的指令。它包括算术逻辑单元（ALU）和控制单元，用于执行各种计算和控制操作。</li><li><strong>存储器（主要指内存）：</strong>存储器用于存储程序指令和数据。在冯·诺伊曼体系结构中，存储器通常分为指令存储器（用于存储程序代码）和数据存储器（用于存储程序操作的数据）两部分。</li><li><strong>输入/输出（I/O）：</strong>计算机与外部世界通信的途径，通过输入设备（如键盘和鼠标）和输出设备（如显示器和打印机）进行数据交换。</li></ol></blockquote><p><img src="C:\Users\Dell\AppData\Roaming\Typora\typora-user-images\image-20230922200228039.png" alt="image-20230922200228039" style="zoom: 50%;" /></p><h4 id="细节概念解析"><a href="#细节概念解析" class="headerlink" title="细节概念解析"></a>细节概念解析</h4><p>在冯·诺伊曼体系结构中，CPU（中央处理器）的主要任务是执行指令和进行数据处理。在<strong>没有考虑缓存的情况下</strong>，CPU与内存（也称为主存储器）之间的交互非常直接，而且<strong>CPU只能与内存进行读写操作，不能直接访问外部设备（例如键盘、鼠标、显示器等输入或输出设备）。</strong></p><p>具体来说：</p><ol><li>CPU与内存之间的关系：<ul><li>CPU可以从内存中读取指令，这些指令通常包括要执行的计算任务的步骤。</li><li>CPU可以将数据从内存中读取到寄存器中，以便执行计算操作。</li><li>CPU可以将计算结果写回内存，以保存或进一步处理数据。</li></ul></li><li>外部设备（输入或输出设备）：<ul><li>外部设备不能直接与CPU通信，而是通过内存进行数据交换。</li><li>例如，键盘输入的数据首先被传送到内存中，然后CPU可以从内存中读取这些数据。</li><li>类似地，CPU生成的输出数据也必须写入内存，然后由外部设备从内存中读取。</li></ul></li></ol><blockquote><p>综上所述，没有缓存的情况下，CPU的操作主要依赖于与内存的读写交互，而外部设备与CPU之间的数据交换也必须通过内存作为中介。CPU无法直接访问外设，而是通过内存来与外设通信。这种设计确保了计算机系统的一致性和可控性。</p></blockquote><p>如果计算机系统<strong>使用了缓存</strong>，那么情况会有所不同。缓存是一种<strong>高速临时存储器</strong>，用于存储常用的数据和指令，以提高CPU的访问速度。在有缓存的情况下，关于CPU、内存和外设之间的交互会发生以下变化：</p><ol><li>CPU与内存之间的关系：<ul><li>CPU可以从缓存中读取指令和数据，而不必每次都访问主内存。</li><li>缓存的目的是<strong>加速</strong>CPU对数据和指令的访问，<strong>因为缓存通常比主内存快速得多。</strong></li></ul></li><li>缓存的工作原理：<ul><li>缓存中存储了<strong>最常用的数据块</strong>（通常是内存中的部分数据）。</li><li>当CPU需要读取数据时，它首先查看缓存。如果数据在缓存中找到（命中缓存），CPU会迅速获取数据，从而提高了访问速度。</li><li>如果数据不在缓存中（缓存未命中），CPU会从主内存中读取数据，然后将其存储到缓存中，以备将来使用。这个过程称为<strong>缓存填充。</strong></li></ul></li><li>缓存与外部设备：<ul><li>缓存通常用于优化CPU与内存之间的数据访问，而不直接用于与外部设备的交互。</li><li>外部设备与CPU之间的数据交换仍然需要通过内存进行，与是否存在缓存无关。</li></ul></li></ol><blockquote><p>总的来说，缓存的引入可以显著提高CPU对内存中数据和指令的访问速度，但对于外部设备的输入和输出，仍然需要通过内存作为中介。外部设备无法直接与缓存或CPU通信，而是通过内存来传输数据。这种体系结构的目标是保持一致性和数据完整性。</p></blockquote><h4 id="缓存解析"><a href="#缓存解析" class="headerlink" title="缓存解析"></a>缓存解析</h4><p><strong>缓存（Cache）</strong>是计算机系统中的一种高速存储器，用于<strong>存储常用的数据和指令</strong>，以提高数据的访问速度。缓存工作原理是利用局部性原理，将最常访问的数据存储在更快的存储介质中，以减少对较慢存储介质（通常是主内存）的访问需求。以下是缓存的详细介绍：</p><ol><li><strong>缓存工作原理</strong>：<ul><li>缓存工作的核心原理是局部性原理，包括时间局部性和空间局部性。</li><li>时间局部性指的是程序在不同的时间点倾向于多次访问相同的数据。空间局部性指的是程序在某个时间点倾向于访问相邻的数据。</li><li>缓存通过存储常用的数据块（数据块通常以缓存行为单位）来利用这些局部性原理，以便更快速地满足CPU的读取需求。</li></ul></li><li><strong>缓存的种类</strong>：<ul><li><strong>指令缓存（Instruction Cache）</strong>：存储CPU执行指令所需的代码，以提高程序执行的速度。</li><li><strong>数据缓存（Data Cache）</strong>：存储CPU需要的数据，以减少数据访问延迟。</li></ul></li><li><strong>缓存层次结构</strong>：<ul><li>计算机系统通常包括多级缓存（通常是L1、L2、L3等），这些缓存位于不同的层次，离CPU越近的缓存越小且更快速。</li><li>L1缓存位于CPU核心内部，L2缓存通常在CPU核心之间共享，L3缓存通常在多个CPU之间共享。</li><li>多级缓存层次结构旨在充分利用不同级别的局部性原理，以提供高性能的数据访问。</li></ul></li><li><strong>缓存替换策略</strong>：<ul><li>当缓存已满且需要将新数据加载到缓存时，需要选择哪些数据应该被替换出去。这涉及到缓存替换策略，常见的包括最近最少使用（LRU）和最不常用（LFU）等。</li><li>替换策略的选择影响了缓存的性能，不同的工作负载可能对不同的策略表现出更好的性能。</li></ul></li><li><strong>缓存一致性</strong>：<ul><li>在多核系统中，多个CPU核心可能具有各自的缓存，需要确保各个核心之间的数据一致性。</li><li>缓存一致性协议（如MESI协议）用于确保各个核心看到的数据是一致的，以避免数据冲突和错误。</li></ul></li><li><strong>缓存的优点和局限性</strong>：<ul><li>优点：缓存可以显著提高计算机系统的性能，因为它减少了对主内存的访问延迟，降低了总线带宽的需求。</li><li>局限性：缓存需要额外的硬件和管理开销，而且在某些情况下，不恰当的缓存使用可能导致数据一致性问题。此外，缓存大小有限，无法完全消除主内存的访问。</li></ul></li></ol><blockquote><p>综上所述，缓存是计算机体系结构中的关键组成部分，旨在通过存储最常用的数据和指令来提高数据访问速度。缓存的设计和管理是一个复杂的工程任务，需要权衡性能、硬件成本和一致性等因素。缓存在计算机系统性能优化中起着重要作用。</p></blockquote><h4 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h4><p>外设（Peripheral Device）是计算机系统中与中央处理单元（CPU）和主内存（RAM）相连但不是核心计算机组件的设备。外设通常用于输入、输出、存储或扩展计算机的功能。它们可以连接到计算机，与计算机进行数据交换和控制，从而扩展了计算机的能力。</p><p>以下是一些常见的外设类型：</p><ol><li><strong>输入设备</strong>：<ul><li>输入设备用于将数据输入到计算机中，以供处理和存储。常见的输入设备包括键盘、鼠标、触摸屏、扫描仪和数字化笔等。</li></ul></li><li><strong>输出设备</strong>：<ul><li>输出设备用于从计算机中输出数据，以供用户查看或使用。常见的输出设备包括显示器、打印机、扬声器和投影仪等。</li></ul></li><li><strong>存储设备</strong>：<ul><li>存储设备用于存储数据以供以后检索和使用。这些设备包括硬盘驱动器、固态硬盘、USB闪存驱动器、光盘驱动器和网络存储设备等。</li></ul></li><li><strong>通信设备</strong>：<ul><li>通信设备用于与计算机网络通信，包括以太网适配器、调制解调器（调制器）、无线网络适配器和路由器等。</li></ul></li><li><strong>图像和音频设备</strong>：<ul><li>图像和音频设备用于处理图像和音频数据，如摄像头、麦克风、图形加速器卡和声卡等。</li></ul></li><li><strong>外部存储设备</strong>：<ul><li>外部存储设备用于扩展计算机的存储容量，并备份数据。这包括外部硬盘驱动器、移动硬盘、网络存储设备和云存储服务等。</li></ul></li><li><strong>扩展卡</strong>：<ul><li>扩展卡是插入到计算机的扩展槽中的卡片，用于增强计算机的功能。常见的扩展卡包括图形卡、声卡、网卡和扩展存储卡等。</li></ul></li></ol><blockquote><p>外设在计算机系统中起到了重要的角色，它们扩展了计算机的功能和用途，使用户能够与计算机交互、输入输出数据，并扩展存储和通信能力。不同类型的外设可以满足不同的计算需求，从而使计算机变得更加多功能化和灵活。</p></blockquote><h4 id="内存掉电易失"><a href="#内存掉电易失" class="headerlink" title="内存掉电易失"></a>内存掉电易失</h4><blockquote><p>内存，通常指的是主内存或RAM（Random Access Memory），是一种易失性存储器。易失性表示内存中存储的数据在断电或关机时会丢失。这是因为内存的工作原理决定了其依赖于持续的电源供应来保持存储的数据。</p></blockquote><p>内存是用于存储正在运行的程序、数据和临时信息的地方，它提供了快速的读写访问速度，以支持计算机的各种操作。然而，内存芯片使用了一种电子存储技术，该技术需要持续的电源供应来保持存储的数据。当电源断开时，内存中的电子状态会逐渐消失，导致存储的数据被清除。</p><p>因此，在计算机中，内存通常被用作临时存储区域，用于存储当前正在执行的程序和数据。但是，如果需要永久性存储数据，通常会使用永久性存储设备，如硬盘驱动器或固态硬盘，这些设备是非易失性存储器，它们可以在断电时保留存储的数据。</p><p>这就是为什么操作系统和应用程序通常会将需要保存的数据定期写入到永久性存储设备中，以避免数据丢失。同时，也是为什么计算机开机时需要从永久性存储设备加载操作系统和应用程序到内存中，因为内存中的数据在关机或重启时会丢失。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>理解冯·诺伊曼体系结构对于理解计算机系统中数据流动过程是非常重要的。</p><p>以下是从登录QQ开始，与朋友聊天，包括发送消息和发送文件的数据流动过程的详细解释，同时突出了冯·诺伊曼体系结构的关键点：</p><p><strong>登录QQ并开始聊天的数据流动过程</strong>：</p><ol><li><strong>用户输入凭据</strong>：<ul><li>用户启动QQ客户端并输入用户名和密码。</li></ul></li><li><strong>数据存储</strong>：<ul><li>输入的用户名和密码被存储在计算机内存中的输入缓冲区中，等待进一步处理。</li></ul></li><li><strong>处理凭据</strong>：<ul><li>计算机的中央处理单元 (CPU) 开始处理输入的用户名和密码，进行验证操作。</li></ul></li><li><strong>数据传输</strong>：<ul><li>如果凭据有效，QQ客户端与QQ服务器建立通信。</li><li>数据通过计算机内部的总线和网络适配器传输到服务器。</li></ul></li><li><strong>服务器验证</strong>：<ul><li>服务器接收到您的凭据并验证它们的有效性。</li><li>服务器可能会将验证结果存储在内部数据库中。</li></ul></li><li><strong>数据返回</strong>：<ul><li>服务器将验证结果传输回您的计算机，可能包括成功登录的消息。</li><li>这些数据存储在内存中，供客户端使用。</li></ul></li><li><strong>登录成功</strong>：<ul><li>如果验证成功，您将被登录到QQ客户端，显示您的好友列表等信息。</li></ul></li></ol><p><strong>发送消息的数据流动过程</strong>：</p><ol><li><strong>用户输入消息</strong>：<ul><li>在聊天窗口中，您键入要发送的消息文本。</li></ul></li><li><strong>数据存储</strong>：<ul><li>消息文本存储在计算机内存中的消息缓冲区中，等待进一步处理。</li></ul></li><li><strong>消息处理</strong>：<ul><li>CPU开始处理消息文本，包括格式化、编码等操作。</li></ul></li><li><strong>数据封装</strong>：<ul><li>消息文本被封装成网络数据包，包括消息内容、目标地址等元数据信息。</li></ul></li><li><strong>数据传输</strong>：<ul><li>数据包通过计算机内部的总线和网络适配器传输到QQ服务器。</li></ul></li><li><strong>服务器接收和转发</strong>：<ul><li>服务器接收到数据包并将消息转发给接收方的QQ客户端。</li></ul></li><li><strong>数据返回</strong>：<ul><li>接收方客户端将消息存储在内存中，等待进一步处理。</li></ul></li><li><strong>处理和显示消息</strong>：<ul><li>接收方客户端的CPU开始处理消息文本，然后将其显示在聊天窗口中供接收方用户查看。</li><li>这可能涉及内存中的数据传输到图形显示系统。</li></ul></li></ol><p><strong>发送文件的数据流动过程</strong>：</p><ol><li><strong>用户选择文件</strong>：<ul><li>用户选择要发送的文件并指定接收方。</li></ul></li><li><strong>数据存储</strong>：<ul><li>所选文件被存储在计算机内存中的特定位置，以备发送。</li></ul></li><li><strong>数据封装和传输</strong>：<ul><li>文件数据被封装成网络数据包，包括文件内容、文件类型、目标地址等元数据信息。</li><li>数据包通过计算机内部的总线和网络适配器传输到QQ服务器。</li></ul></li><li><strong>服务器接收和传递</strong>：<ul><li>服务器接收到文件数据包并将文件传递给接收方的QQ客户端。</li></ul></li><li><strong>接收和存储文件</strong>：<ul><li>接收方客户端接收到文件数据包后，将文件数据存储在内存中或硬盘上的指定位置。</li></ul></li><li><strong>文件处理和显示</strong>：<ul><li>接收方用户可以选择打开或保存文件，进行进一步的处理。</li></ul></li></ol><blockquote><p>在这些过程中，数据在计算机内存、网络适配器和服务器之间流动，符合冯·诺伊曼体系结构的基本原则。计算机硬件和软件协同工作，确保数据安全地传输、处理和显示，实现了各种操作，包括登录、消息传递和文件传输。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Linux』初识进程</title>
      <link href="/2023/09/22/%E3%80%8ELinux%E3%80%8F%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/09/22/%E3%80%8ELinux%E3%80%8F%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初识进程概念"><a href="#初识进程概念" class="headerlink" title="初识进程概念"></a>初识进程概念</h1><blockquote><p>进程是计算机科学中的重要概念，用于描述正在运行的程序的基本单位。它是操作系统管理和分配系统资源的基本单元，包括CPU时间、内存空间和输入/输出设备等。</p><p>当你使用计算机时，你可以将进程想象成是计算机上运行的不同任务或程序的容器。每个进程都有自己的空间，它包含了程序代码、数据和其他必要的信息。</p></blockquote><p>1.<strong>程序和进程的区别</strong></p><p>程序是一个静态的文件或指令集，而进程是程序在执行时的动态实例。一个程序可以对应多个进程的实例。</p><p>2.<strong>进程是程序的执行实例</strong></p><p>想象计算机上运行的程序就像是你电脑里的应用程序，如浏览器或文字处理软件。进程则是这些应用程序的实际运行实例。每次你打开一个应用程序，就会创建一个新的进程。</p><p>3.<strong>进程有自己的空间</strong></p><p>每个进程都有自己独立的内存空间，这意味着一个进程无法直接访问其他进程的数据。这是为了保护你的数据隐私和确保程序之间不会相互干扰。</p><p>4.<strong>进程的特征</strong></p><ul><li><strong>独立性</strong>：每个进程都是相互独立的，一个进程的崩溃不会影响其他进程。</li><li><strong>拥有资源</strong>：每个进程有自己的内存空间、寄存器和文件描述符等资源。</li><li><strong>并发性</strong>：多个进程可以同时运行，操作系统通过时间片轮转等方式来实现并发执行。</li></ul><p>5.<strong>进程控制块（PCB）</strong></p><p>每个进程都有一个与之相关联的数据结构，称为进程控制块。<strong>PCB</strong> 包含了有关进程的所有信息，如进程状态、程序计数器、寄存器值、内存分配情况、打开文件列表等。</p><p>6.<strong>进程间通信（IPC）</strong></p><p>不同进程之间需要进行数据交换和通信的情况下，可以使用 <strong>IPC</strong> 机制，如管道、消息队列、共享内存等。</p><blockquote><p>总之，进程是操作系统中的基本执行单位，它允许多个程序同时运行，并提供了一种有效管理和控制计算机资源的方式，以满足各种应用程序的需求。进程的概念对于理解操作系统和并发编程非常重要。</p></blockquote><h1 id="PCB（Process-Control-Block）"><a href="#PCB（Process-Control-Block）" class="headerlink" title="PCB（Process Control Block）"></a>PCB（Process Control Block）</h1><h2 id="通用-PCB"><a href="#通用-PCB" class="headerlink" title="通用 PCB"></a><strong>通用 PCB</strong></h2><blockquote><p>PCB（Process Control Block，进程控制块）是操作系统中用于管理和维护进程信息的数据结构。每个进程在操作系统中都有一个相关联的 PCB，PCB 包含了有关进程的重要信息，以便操作系统能够对其进行管理和控制。</p></blockquote><p>以下是 PCB 中可能包含的信息和属性：</p><ol><li><strong>进程状态（Process State）</strong>：PCB 记录了进程的当前状态，例如就绪（Ready）、运行（Running）、阻塞（Blocked）或终止（Terminated）等。</li><li><strong>程序计数器（Program Counter）</strong>：也称为指令指针，它包含了进程当前执行的指令位置。当操作系统切换进程时，它会保存和恢复程序计数器的值，以确保进程继续执行。</li><li><strong>寄存器状态（Register State）</strong>：PCB 记录了进程在CPU中的寄存器内容。这包括通用寄存器、堆栈指针和程序状态寄存器等。这些寄存器的值在进程切换时被保存和恢复。</li><li><strong>进程优先级和调度信息</strong>：PCB 可能包含进程的优先级和调度信息，以帮助操作系统在多个进程之间进行调度和分配 CPU 时间。</li><li><strong>进程标识符（Process Identifier）</strong>：每个进程都有一个唯一的标识符，通常是一个整数，用于在操作系统中标识和查找进程。</li><li><strong>进程的父子关系信息</strong>：PCB 可能包含有关进程的父进程和子进程的信息，以便进行进程间通信和管理。</li><li><strong>内存管理信息</strong>：PCB 可能包含有关进程内存分配和使用的信息，包括进程的地址空间大小、页表信息等。</li><li><strong>文件描述符表（File Descriptor Table）</strong>：进程通常会打开文件或网络连接，PCB 可能包含有关这些打开文件的信息，以便在进程之间共享文件或进行文件操作。</li><li><strong>进程统计信息</strong>：一些操作系统可能记录进程的运行时间、CPU 使用情况和其他性能统计信息。</li></ol><blockquote><p>PCB 是操作系统内核的一部分，它们用于跟踪和管理系统中运行的所有进程。当操作系统需要切换到另一个进程时，它会保存当前进程的 PCB 信息，加载下一个进程的 PCB，然后继续执行。这种方式实现了多任务处理和进程的并发执行。 PCB信息的细节和结构可能因操作系统的不同而有所不同，但通常包含上述核心信息以及其他操作系统特定的信息。</p></blockquote><h2 id="Linux-内核中的-task-struct"><a href="#Linux-内核中的-task-struct" class="headerlink" title="Linux 内核中的 task_struct"></a><strong>Linux 内核中的 <code>task_struct</code></strong></h2><blockquote><p><code>task_struct</code> 是一个特定于 Linux 内核的数据结构，用于表示和管理进程（任务）的详细信息。它是 Linux 内核中非常重要的数据结构之一，包含了关于一个进程的所有关键信息，类似于其他操作系统中的 PCB（Process Control Block）。</p></blockquote><ol><li><strong>进程标识符（Process Identifier）</strong>：<ul><li>每个进程都有一个唯一的标识符，通常是一个整数，用于操作系统区分不同的进程。</li></ul></li><li><strong>程序计数器（Program Counter，PC）</strong>：<ul><li>PC 存储了进程下一条将要执行的指令的地址。当进程被切换时，PC 的值会被保存和恢复，以确保进程在恢复执行时从正确的位置开始。</li></ul></li><li><strong>寄存器集合（Registers）</strong>：<ul><li>PCB 包含了进程在CPU中的寄存器的值，包括通用寄存器、堆栈指针寄存器、程序状态寄存器等。这些寄存器的值在进程切换时需要保存和恢复。</li></ul></li><li><strong>进程状态（Process State）</strong>：<ul><li>PCB 记录了进程的状态，如就绪、运行、阻塞等。这有助于操作系统了解哪些进程可以运行，哪些需要等待或被阻塞。</li></ul></li><li><strong>进程优先级和调度信息</strong>：<ul><li>PCB 可能包含有关进程优先级的信息，以及操作系统用于调度进程的信息，例如时间片大小或调度策略。</li></ul></li><li><strong>进程的父子关系信息</strong>：<ul><li>进程通常可以创建其他进程，PCB 中可能包含有关父子进程关系的信息，以便操作系统跟踪和管理这些关系。</li></ul></li><li><strong>内存管理信息</strong>：<ul><li>PCB 包含了有关进程的内存分配和使用情况的信息，包括地址空间大小、页表信息等。</li></ul></li><li><strong>文件描述符表（File Descriptor Table）</strong>：<ul><li>进程可以打开文件或网络连接，PCB 包含了有关这些打开文件的信息，以便进程能够访问它们，也用于文件共享和管理。</li></ul></li><li><strong>进程统计信息</strong>：<ul><li>一些操作系统记录有关进程的性能统计信息，如运行时间、CPU 使用情况、内存使用情况等。</li></ul></li><li><strong>其他操作系统特定的信息</strong>：<ul><li>不同的操作系统可能在 PCB 中包含其他特定于操作系统的信息，以满足特定的需求。</li></ul></li></ol><blockquote><p>请注意，<code>task_struct</code> 结构在不同版本的 Linux 内核中可能会有所不同，并且具体字段和细节可能会因内核版本而异。这个数据结构是内核的核心部分，用于管理和控制进程。不同的字段和成员用于支持各种进程管理和调度操作。</p></blockquote><h2 id="PCB产生原因"><a href="#PCB产生原因" class="headerlink" title="PCB产生原因"></a>PCB产生原因</h2><blockquote><p>进程控制块（PCB，Process Control Block）在操作系统中具有关键作用，以下是更详细的解释为什么需要 PCB：</p></blockquote><ol><li><strong>多任务处理</strong>：现代操作系统需要同时管理多个进程或任务。PCB 允许操作系统在这些进程之间进行切换，以实现并发执行。当一个进程在等待外部事件（如输入/输出完成）或时间片耗尽时，操作系统会保存当前进程的状态（使用 PCB）并切换到另一个进程，从而实现进程间的快速切换和并发执行。</li><li><strong>进程状态跟踪</strong>：PCB 包含了关于进程的各种信息，如进程的标识符、状态、寄存器值、程序计数器（PC）等。这些信息允许操作系统了解每个进程的当前状态以及何时需要进行进程调度。</li><li><strong>进程隔离</strong>：每个进程都有自己的地址空间，这意味着它们无法直接访问其他进程的内存。PCB 有助于维护这种隔离，确保一个进程的错误或崩溃不会对其他进程造成影响。</li><li><strong>资源管理</strong>：PCB 包含了进程所拥有的资源信息，如打开的文件、分配的内存等。操作系统可以使用这些信息来协调进程对资源的访问，以确保资源的合理共享和分配。</li><li><strong>进程调度</strong>：PCB 中的信息包括进程的优先级和调度信息。这允许操作系统使用不同的调度算法来决定哪个进程获得 CPU 时间片，以实现各种调度策略，如轮转调度、优先级调度等。</li><li><strong>进程同步和通信</strong>：PCB 包含了进程间通信（IPC）所需的信息。这可以用于实现进程之间的消息传递、共享内存等机制，以便进程可以相互协作和通信。</li><li><strong>进程终止和资源释放</strong>：当一个进程终止时，PCB 中包含的信息用于释放该进程占用的资源，包括内存、打开的文件描述符等，以确保资源得到有效回收。</li></ol><blockquote><p>总之，PCB 是操作系统中的关键数据结构，用于管理和控制进程。它允许操作系统有效地管理多个并发运行的进程，确保它们能够有序地访问计算机资源，维护进程的隔离性，实现多任务处理和资源管理，以提供高性能、稳定性和安全性的操作系统环境。没有 PCB，现代操作系统无法有效地实现多任务处理和进程管理。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>通用 PCB（Process Control Block）</strong>：<ul><li><strong>概念</strong>：通用 PCB 是操作系统中用于管理进程的核心数据结构之一。它负责存储和维护有关进程的所有信息，以便操作系统能够对进程进行管理和控制。</li><li><strong>内容</strong>：通用 PCB 包含了各种关于进程的信息，包括但不限于：<ul><li>进程标识符（PID）：唯一标识每个进程的数字。</li><li>程序计数器（Program Counter，PC）：保存下一条要执行的指令的地址。</li><li>寄存器状态：包括通用寄存器、堆栈指针、程序状态寄存器等。</li><li>进程状态：记录进程的状态，如就绪、运行、阻塞等。</li><li>进程优先级和调度信息：包括进程的优先级和调度策略。</li><li>父子进程关系：指向父进程或子进程的指针。</li><li>内存管理信息：包括地址空间大小、页表等。</li><li>文件描述符表：用于管理打开的文件和网络连接。</li><li>进程统计信息：如 CPU 时间、启动时间等。</li></ul></li><li><strong>用途</strong>：通用 PCB 的主要目的是支持多任务操作系统。当操作系统需要切换到另一个进程时，它会保存当前进程的 PCB 信息，加载下一个进程的 PCB，以便继续执行。通用 PCB 用于实现进程的并发和管理。</li></ul></li><li><strong>Linux 内核中的 <code>task_struct</code></strong>：<ul><li><strong>概念</strong>：<code>task_struct</code> 是 Linux 内核中用于表示和管理进程的具体数据结构。它是 Linux 特有的 PCB 实现，包含了详细的信息。</li><li><strong>内容</strong>：<code>task_struct</code> 结构包含了大量关于进程的信息，包括通用 PCB 中的内容以及 Linux 特定的字段，如进程命名空间、信号处理器、调度信息等。具体字段和成员可能因内核版本而异。</li><li><strong>用途</strong>：<code>task_struct</code> 用于管理和控制 Linux 内核中运行的进程。当操作系统需要进行进程调度或切换到不同的进程时，它会使用 <code>task_struct</code> 结构来保存和恢复进程的状态和信息。</li></ul></li></ol><blockquote><p>总结：通用 PCB 是一个操作系统概念，用于表示和管理进程的基本信息，而 <code>task_struct</code> 是 Linux 内核中的具体实现，包含了更多详细信息以支持 Linux 特定的功能和调度策略。这两种 PCB 都是操作系统中非常重要的数据结构，用于支持多任务处理和进程管理。在不同的操作系统中，通用 PCB 的实现方式可能不同，而 <code>task_struct</code> 是 Linux 内核的一部分。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Linux』探索Linux进程状态</title>
      <link href="/2023/09/22/%E3%80%8ELinux%E3%80%8F%E6%8E%A2%E7%B4%A2Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
      <url>/2023/09/22/%E3%80%8ELinux%E3%80%8F%E6%8E%A2%E7%B4%A2Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在计算机科学的世界中，进程是一个核心概念。无论您是一名系统管理员、一名开发人员，还是只是对计算机操作系统感兴趣的普通用户，都需要理解进程是如何工作的。Linux作为一种广泛使用的操作系统，以其卓越的性能和可定制性而闻名，而Linux内核中的进程管理是其内核力量的一部分。</p><blockquote><p>进程是计算机上运行的程序的实例，它们可以并行执行，执行各种任务，从简单的文本编辑器到复杂的服务器应用。然而，这些进程的状态却是多变的，而深入了解这些状态可以帮助我们更好地理解和优化Linux系统。</p><p>在本博客中，我们将深入探讨Linux内核进程状态的世界，解释每个状态的含义、如何监视它们以及在不同状态下如何进行适当的处理。无论您是要解决性能问题、进行系统调优还是简单地了解操作系统的运行方式，这些知识都将对您有所帮助。</p></blockquote><p>从<strong>运行状态</strong>到<strong>僵尸状态</strong>，我们将带您穿越Linux进程状态的全貌，让您更深入地了解Linux操作系统的内部机制。</p><h1 id="Linux进程状态"><a href="#Linux进程状态" class="headerlink" title="Linux进程状态"></a>Linux进程状态</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* The task state array is a strange &quot;bitmap&quot; of</span></span><br><span class="line"><span class="comment">* reasons to sleep. Thus &quot;running&quot; is zero, and</span></span><br><span class="line"><span class="comment">* you can test for combinations of others with</span></span><br><span class="line"><span class="comment">* simple bit tests.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line"><span class="string">&quot;R (running)&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line"><span class="string">&quot;S (sleeping)&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line"><span class="string">&quot;D (disk sleep)&quot;</span>, <span class="comment">/* 2 */</span></span><br><span class="line"><span class="string">&quot;T (stopped)&quot;</span>, <span class="comment">/* 4 */</span></span><br><span class="line"><span class="string">&quot;t (tracing stop)&quot;</span>, <span class="comment">/* 8 */</span></span><br><span class="line"><span class="string">&quot;X (dead)&quot;</span>, <span class="comment">/* 16 */</span></span><br><span class="line"><span class="string">&quot;Z (zombie)&quot;</span>, <span class="comment">/* 32 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码定义了一个名为<code>task_state_array</code>的数组，该数组用于表示Linux内核中任务（或进程）的不同状态。这个数组的目的是将每种任务状态映射到一个<strong>位掩码</strong>，以便在内核中进行位操作来检查和管理任务的状态。</p></blockquote><h2 id="位掩码"><a href="#位掩码" class="headerlink" title="位掩码"></a>位掩码</h2><p>位掩码是一种在编程中用来对某些特定位进行操作的技术。它通常涉及到使用位运算符（如位与、位或、位异或等）来设置、清除或测试特定位的值。位掩码的主要目的是允许对一个整数或一组标志进行高效的单独位操作。</p><p>让我们更详细地解释位掩码的概念：</p><ol><li><p><strong>位运算符</strong>：</p><ul><li><strong>位与（&amp;）</strong>：将两个二进制数的对应位进行与操作，只有当两个位都为1时，结果位才为1。</li><li><strong>位或（|）</strong>：将两个二进制数的对应位进行或操作，只要其中一个位为1，结果位就为1。</li><li><strong>位异或（^）</strong>：将两个二进制数的对应位进行异或操作，只有当两个位不同（一个为0，一个为1）时，结果位才为1。</li><li><strong>位取反（~）</strong>：将一个二进制数的每个位取反，0变为1，1变为0。</li></ul></li><li><p><strong>位掩码的作用</strong>：位掩码通常用于以下几种情况：</p><ul><li><strong>标志操作</strong>：使用位掩码来设置、清除或测试一组标志位，以便在一个整数中表示多个状态或属性。</li><li><strong>权限和访问控制</strong>：将权限信息编码为位掩码，以便进行权限检查和授权。</li><li><strong>硬件寄存器操作</strong>：在底层硬件编程中，位掩码用于与硬件寄存器的特定位进行交互，以配置硬件设备或读取状态信息。</li></ul></li><li><p><strong>位掩码的示例</strong>：假设你希望管理文件的读取、写入和执行权限。你可以为每个权限分配一个唯一的位掩码值：</p><ul><li>读取权限：0001</li><li>写入权限：0010</li><li>执行权限：0100</li></ul><p>现在，你可以将这些权限按位组合，以表示文件的实际权限。例如，要为文件分配读取和写入权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> filePermissions = READ_PERMISSION | WRITE_PERMISSION; <span class="comment">// 文件具有读取和写入权限</span></span><br></pre></td></tr></table></figure></li><li><p><strong>检查权限</strong>：使用位与运算符可以轻松检查文件是否具有特定权限。例如，要检查文件是否具有执行权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (filePermissions &amp; EXECUTE_PERMISSION) &#123;</span><br><span class="line">    <span class="comment">// 文件具有执行权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>添加和删除权限</strong>：使用位或和位与运算符，你可以添加或删除权限而不影响其他权限。例如，要向文件添加执行权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filePermissions |= EXECUTE_PERMISSION; <span class="comment">// 添加执行权限</span></span><br></pre></td></tr></table></figure><p>要从文件中删除写入权限：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filePermissions &amp;= ~WRITE_PERMISSION; <span class="comment">// 删除写入权限</span></span><br></pre></td></tr></table></figure></li><li><p><strong>位掩码的性能优势</strong>：位掩码通常比使用单独的布尔变量或枚举更加高效，因为它们允许在单个整数上进行多个状态的快速操作，而不需要使用条件语句。这在处理大量状态或标志时特别有用。</p></li></ol><blockquote><p>总之，位掩码是一种强大的技术，用于管理和操作二进制数据中的特定位，通常用于表示多个状态或标志。它在编程中经常用于系统编程、嵌入式编程和许多其他领域，以实现高效的位级操作。</p></blockquote><h3 id="位掩码进程状态应用"><a href="#位掩码进程状态应用" class="headerlink" title="位掩码进程状态应用"></a>位掩码进程状态应用</h3><p>当在操作系统内核中管理进程状态时，使用位掩码是一种有效且高效的方法，它允许你表示和操作多个状态，而无需使用大量的布尔变量或复杂的条件语句。011111111111111111111111111111111111111111111111111111111111111111111111111111111122</p><ol><li><p><strong>定义状态位掩码</strong>：首先，你需要为每个可能的进程状态定义一个唯一的位掩码值。这些位掩码值通常是2的幂次方值，以确保每个状态都有一个不同的位表示。在你的示例中，状态位掩码可以如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RUNNING     (1 &lt;&lt; 0) <span class="comment">// 位掩码值为 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLEEPING    (1 &lt;&lt; 1) <span class="comment">// 位掩码值为 2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISK_SLEEP  (1 &lt;&lt; 2) <span class="comment">// 位掩码值为 4</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STOPPED     (1 &lt;&lt; 3) <span class="comment">// 位掩码值为 8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRACING     (1 &lt;&lt; 4) <span class="comment">// 位掩码值为 16</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEAD        (1 &lt;&lt; 5) <span class="comment">// 位掩码值为 32</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZOMBIE      (1 &lt;&lt; 6) <span class="comment">// 位掩码值为 64</span></span></span><br></pre></td></tr></table></figure><p>这里，每个状态都有一个唯一的位掩码值，它们是2的幂次方值，确保它们可以单独表示和组合。</p></li><li><p><strong>表示进程状态</strong>：要表示一个进程的状态，你可以使用位掩码的按位或操作将相应的状态位掩码合并在一起。例如，如果一个进程既处于运行状态又处于睡眠状态，可以这样表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> processStatus = RUNNING | SLEEPING; <span class="comment">// 进程同时处于运行和睡眠状态</span></span><br></pre></td></tr></table></figure><p>这将在<code>processStatus</code>变量中使用位掩码来表示进程的状态。</p></li><li><p><strong>检查进程状态</strong>：使用位与操作可以轻松地检查进程是否处于特定状态。例如，要检查进程是否处于运行状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (processStatus &amp; RUNNING) &#123;</span><br><span class="line">    <span class="comment">// 进程处于运行状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类似的方式，你可以测试其他状态，如睡眠状态、磁盘睡眠状态等。</p></li><li><p><strong>多状态组合</strong>：位掩码允许你高效地测试多个状态的组合。例如，如果你想检查进程是否同时处于运行状态和睡眠状态，只需使用位与操作来测试这两个状态的位掩码是否都被设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((processStatus &amp; RUNNING) &amp;&amp; (processStatus &amp; SLEEPING)) &#123;</span><br><span class="line">    <span class="comment">// 进程同时处于运行和睡眠状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这避免了使用多个布尔变量或复杂的条件语句来管理进程状态。</p></li><li><p><strong>修改进程状态</strong>：使用位操作，你可以轻松地修改进程的状态。例如，如果要将进程从运行状态切换到睡眠状态，可以使用位与操作来清除运行状态位并设置睡眠状态位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">processStatus &amp;= ~RUNNING;  <span class="comment">// 清除运行状态位</span></span><br><span class="line">processStatus |= SLEEPING;  <span class="comment">// 设置睡眠状态位</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>总之，位掩码是一种非常有效的方式来管理和操作多个状态或标志。在操作系统内核等低级编程中，它可以使代码更加紧凑、高效和易于维护，因为它允许你在单个整数上执行多个状态操作，而无需引入大量的变量和条件逻辑。</p></blockquote><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><h3 id="宏观解析各类进程状态"><a href="#宏观解析各类进程状态" class="headerlink" title="宏观解析各类进程状态"></a>宏观解析各类进程状态</h3><p>Linux内核中的进程状态是一个关键的概念，它用于跟踪和管理操作系统中运行的进程。在内核中，这些状态通常用位掩码来表示，位掩码是一个二进制数，每个位都代表一种状态。下面详细解释了Linux内核中使用的进程状态位掩码和对应的文本描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line">    <span class="string">&quot;R (running)&quot;</span>,       <span class="comment">/* 0 */</span></span><br><span class="line">    <span class="string">&quot;S (sleeping)&quot;</span>,      <span class="comment">/* 1 */</span></span><br><span class="line">    <span class="string">&quot;D (disk sleep)&quot;</span>,    <span class="comment">/* 2 */</span></span><br><span class="line">    <span class="string">&quot;T (stopped)&quot;</span>,       <span class="comment">/* 4 */</span></span><br><span class="line">    <span class="string">&quot;t (tracing stop)&quot;</span>,  <span class="comment">/* 8 */</span></span><br><span class="line">    <span class="string">&quot;X (dead)&quot;</span>,          <span class="comment">/* 16 */</span></span><br><span class="line">    <span class="string">&quot;Z (zombie)&quot;</span>         <span class="comment">/* 32 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p><strong>R (running) - 运行状态 (位掩码值：0)</strong>：</p><ul><li>描述：进程正在执行（在CPU上运行）或者处于就绪状态（在运行队列中等待CPU执行）。</li><li>意义：这是进程处于活跃执行状态的标志，它正在占用CPU时间。</li><li><strong>进程正在执行（在CPU上运行）</strong>：当一个进程处于 “R (running)” 状态时，它实际上<strong>正在消耗 CPU 时间</strong>，执行其指定的任务。这是进程处于最活跃状态的情况，它正在运行中，使用 CPU 资源。</li><li><strong>进程在运行队列中等待</strong>：另一种情况是，当一个进程需要执行但当前没有分配到CPU时，它会被<strong>放置在运行队列中等待CPU的分配</strong>。这时进程状态仍然被标记为 “R (running)”，尽管它实际上还没有开始执行。这是因为操作系统将其标记为“准备好执行”，只要有CPU时间可用，它就可以立即开始运行。</li></ul></li><li><p><strong>S (sleeping) - 睡眠状态 (位掩码值：1)</strong>：</p><ul><li>描述：进程进入睡眠状态，通常因为它在等待某些事件的发生，如等待I/O操作完成或等待信号。</li><li>意义：在这个状态下，进程没有活跃执行，它在等待外部事件的发生。</li></ul></li><li><p><strong>D (disk sleep) - 磁盘睡眠状态 (位掩码值：2)</strong>：</p><ul><li>描述：进程处于磁盘休眠状态，通常是因为它在等待磁盘I/O操作完成。</li><li>意义：这是睡眠状态的一种特殊情况，表示进程等待磁盘操作的完成。</li></ul></li><li><p><strong>T (stopped) - 停止状态 (位掩码值：4)</strong>：</p><ul><li>描述：进程被明确地停止或暂停，通常是由于接收到SIGSTOP信号或类似的停止信号。</li><li>意义：在这个状态下，进程不再执行，但它仍然存在，等待继续执行。</li></ul></li><li><p><strong>t (tracing stop) - 跟踪停止状态 (位掩码值：8)</strong>：</p><ul><li>描述：这是一种特殊的停止状态，表示进程正在被调试器跟踪。</li><li>意义：进程停止执行以供调试器检查其状态，通常用于调试目的。</li></ul></li><li><p><strong>X (dead) - 死亡状态 (位掩码值：16)</strong>：</p><ul><li>描述：表示进程已经终止或被销毁，不再存在。</li><li>意义：在这个状态下，进程已经完成了其执行，但其描述信息仍然在内核中存在。</li></ul></li><li><p><strong>Z (zombie) - 僵尸状态 (位掩码值：32)</strong>：</p><ul><li>描述：这是进程在终止后的中间状态，表示进程已经终止，但其父进程还没有等待获取其终止状态。</li><li>意义：一旦父进程等待获取终止状态，僵尸进程将被完全销毁。</li></ul></li></ol><p>这些状态位掩码用于表示和管理进程的状态变化。进程通常会在这些状态之间转换，具体取决于它的活动和操作系统的调度。了解和监视这些状态对于操作系统的正常运行和故障排除非常重要。这个位掩码数组提供了对这些状态的清晰描述，以帮助开发人员和系统管理员更好地理解进程的状态。</p><h3 id="S-sleeping-与-D-disk-sleep"><a href="#S-sleeping-与-D-disk-sleep" class="headerlink" title="S (sleeping) 与 D (disk sleep)"></a><code>S (sleeping)</code> 与 <code>D (disk sleep)</code></h3><p>理解”S (sleeping)” 和 “D (disk sleep)” 进程状态的区别确实很重要，因为它们涉及不同的场景和影响。让我们更详细地解释它们的区别：</p><h4 id="S-sleeping-睡眠状态-："><a href="#S-sleeping-睡眠状态-：" class="headerlink" title="S (sleeping) - 睡眠状态 ："></a><strong>S (sleeping) - 睡眠状态 </strong>：</h4><blockquote><ul><li><p><strong>场景</strong>：</p><ul><li>进程通常进入 S 睡眠状态，因为它主动等待某些事件或条件的发生。这些事件可以是等待用户输入、等待网络数据、等待信号、等待资源解锁或等待其他进程完成等。</li><li>这种状态是正常的，因为它表示进程正在等待某些操作的完成或等待外部事件的触发。</li></ul></li><li><p><strong>影响</strong>：</p><ul><li>S 睡眠状态的进程通常不会占用 CPU 时间，因为它们正在等待外部事件。这意味着它们不会导致明显的 CPU 负载。</li><li>在系统性能方面，S 睡眠状态的进程不会导致太大的开销。它们只有在等待事件期间才会挂起，而一旦事件发生，它们就会被唤醒并继续执行。</li></ul></li></ul></blockquote><h5 id="睡眠状态实例："><a href="#睡眠状态实例：" class="headerlink" title="睡眠状态实例："></a><strong>睡眠状态实例</strong>：</h5><blockquote><ol><li><p><strong>等待用户输入</strong>：一个命令行程序等待用户输入命令，当用户没有输入时，进程可能会进入睡眠状态。它会等待用户键入命令并按回车键。</p></li><li><p><strong>等待网络数据</strong>：一个网络服务器进程等待从客户端接收数据。如果没有数据到达，服务器进程可能会进入睡眠状态，以避免不必要的 CPU 使用。</p></li><li><p><strong>等待资源解锁</strong>：多个进程尝试获取一个共享资源的锁。如果某个进程无法获得锁，它可能会进入睡眠状态，等待其他进程释放锁。</p></li></ol></blockquote><h4 id="D-disk-sleep-磁盘睡眠状态："><a href="#D-disk-sleep-磁盘睡眠状态：" class="headerlink" title="D (disk sleep) - 磁盘睡眠状态："></a><strong>D (disk sleep) - 磁盘睡眠状态：</strong></h4><blockquote><p>当一个进程处于深度睡眠状态（D状态）时，它通常是由于等待某些不可中断的事件或资源完成而被挂起的。深度睡眠是Linux中进程状态的一种，与其他状态（如运行、可中断睡眠等）不同，因为它在很大程度上受限于底层系统和硬件的工作。</p></blockquote><ol><li><p><strong>进程状态的演变</strong>：</p><ul><li><p><strong>运行状态（Running）</strong>：进程当前正在执行指令。</p></li><li><p><strong>可中断睡眠状态（Interruptible Sleep）</strong>：进程等待某些事件的发生，这些事件可以是中断、信号、数据等。进程可以在这个状态下被打断，以响应中断或其他事件。</p></li><li><p><strong>不可中断睡眠状态（Uninterruptible Sleep）</strong>：进程等待某些不可中断的事件，通常是底层硬件资源或内核操作，例如等待磁盘I/O完成、等待硬件中断。进程在这个状态下是不可中断的，不能被正常终止。</p></li></ul></li><li><p><strong>D状态的特点</strong>：</p><ul><li><p><strong>不可中断性</strong>：D状态的进程是不可中断的，这意味着它们无法通过普通的终止信号（如<code>SIGTERM</code>）来终止。这是为了确保在等待底层资源时不会发生数据损坏或系统不稳定。</p></li><li><p><strong>等待硬件资源</strong>：D状态通常是由于进程等待硬件资源或底层内核操作而导致的。例如，一个进程可能在等待磁盘I/O完成，但由于磁盘操作不可中断，所以它无法继续执行。</p></li><li><p><strong>系统稳定性</strong>：D状态的进程通常不会对系统的整体稳定性产生重大影响，因为它们被设计成不可中断的，这意味着它们不会妨碍其他进程的正常执行。</p></li></ul></li><li><p><strong>常见原因</strong>：</p><ul><li><p><strong>硬件故障</strong>：硬件故障或问题可能导致进程进入D状态，例如磁盘故障。</p></li><li><p><strong>驱动程序问题</strong>：不正确的或过时的硬件驱动程序可能导致进程陷入深度睡眠状态。</p></li><li><p><strong>文件系统问题</strong>：文件系统损坏或其他文件系统问题可能导致进程进入D状态。</p></li></ul></li><li><p><strong>处理D状态进程</strong>：</p><ul><li><p><strong>故障排除</strong>：确定导致进程进入D状态的根本原因非常重要。这通常需要详细的系统故障排除，包括检查硬件健康状况、更新驱动程序、修复文件系统等。</p></li><li><p><strong>系统重启</strong>：在某些情况下，如果无法快速解决问题，可能需要重启系统，以便清除D状态进程并恢复系统正常运行。</p></li><li><p><strong>升级或修复</strong>：在一些情况下，可能需要升级操作系统、修复硬件或更换受损的组件，以解决D状态问题。</p></li></ul></li></ol><blockquote><p>深度睡眠状态是Linux系统中的一个特殊状态，通常需要仔细的故障排除和维护来解决潜在的问题。要处理D状态进程，通常需要深入了解系统的硬件和操作系统配置，并在必要时采取适当的措施来修复问题。这通常需要系统管理员或高级用户的介入。</p></blockquote><h5 id="磁盘睡眠状态实例："><a href="#磁盘睡眠状态实例：" class="headerlink" title="磁盘睡眠状态实例："></a><strong>磁盘睡眠状态实例</strong>：</h5><blockquote><ol><li><p><strong>文件读取</strong>：一个进程正在从磁盘上的大文件中读取数据。由于磁盘读取速度较慢，进程可能会进入磁盘睡眠状态，等待数据从磁盘加载到内存。</p></li><li><p><strong>文件写入</strong>：一个进程正在将大量数据写入磁盘。由于写入操作可能需要较长时间，进程可能会进入磁盘睡眠状态，等待数据成功写入磁盘。</p></li><li><p><strong>磁盘故障</strong>：如果硬盘遇到故障或出现问题，相关的磁盘 I/O 操作可能会进入 D 磁盘睡眠状态，因为硬盘无法响应读取或写入请求。</p></li></ol></blockquote><p>需要注意的是，这些实际例子只是说明了可能导致进程进入睡眠状态的情况。<strong>在实际系统中，有许多其他因素可能会影响进程状态</strong>，包括操作系统调度、多任务处理、I/O 子系统性能等。监视工具和系统日志可以帮助您更好地理解和识别进程状态，并采取必要的措施来调整系统性能或处理问题。</p><h3 id="僵尸状态"><a href="#僵尸状态" class="headerlink" title="僵尸状态"></a>僵尸状态</h3><blockquote><p><strong>僵尸进程（Zombie Process）</strong>是指已经终止但其终止状态尚未被其父进程收集的进程。在Unix-like操作系统（包括Linux）中，当一个子进程终止时，其终止状态信息仍然需要由其父进程收集，以便操作系统可以释放子进程占用的资源。如果父进程没有正确处理这些终止状态，子进程就会变成僵尸进程。</p></blockquote><p><strong>概念解释</strong>：</p><ol><li><strong>进程生命周期</strong>：进程通常经历创建、运行和终止三个阶段。当进程终止时，它变成一个僵尸进程，等待其父进程调用<code>wait()</code>或<code>waitpid()</code>系统调用来收集其终止状态。</li><li><strong>终止状态</strong>：终止状态包含有关子进程终止的信息，如退出代码、终止原因等。这些信息对于父进程了解子进程的终止情况非常重要。</li><li><strong>父进程的责任</strong>：父进程负有责任及时处理其子进程的终止状态，以避免子进程成为僵尸进程。通常，父进程应该在子进程终止后调用<code>wait()</code>或<code>waitpid()</code>来等待终止状态，并在获取状态后释放子进程的资源。</li></ol><h4 id="僵尸进程实例"><a href="#僵尸进程实例" class="headerlink" title="僵尸进程实例"></a>僵尸进程实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is running.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 子进程退出，成为僵尸进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process is running.\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 父进程不等待子进程，没有处理终止状态</span></span><br><span class="line">        <span class="comment">// 这将导致子进程成为僵尸进程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个示例中，父进程创建一个子进程，但父进程没有等待子进程的终止状态，也没有处理它。因此，当子进程终止后，它会变成一个僵尸进程，因为父进程没有收集其终止状态。</p></blockquote><p>要测试这个示例，可以将其编译为可执行文件，然后运行。在父进程和子进程都运行后，可以使用<code>ps</code>命令查看进程状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc zombie_example.c -o zombie_example</span><br><span class="line">$ ./zombie_example</span><br><span class="line">Parent process is running.</span><br><span class="line">Child process is running.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，打开另一个终端窗口并运行以下命令，以查看僵尸进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep zombie_example</span><br></pre></td></tr></table></figure><p>你将看到输出中存在一个僵尸进程（状态为Z），这是因为父进程没有处理子进程的终止状态。要解决僵尸进程问题，父进程应该在<code>fork</code>之后等待子进程终止，并使用<code>wait</code>或<code>waitpid</code>等函数来处理子进程的终止状态。</p><h4 id="等待子进程实例"><a href="#等待子进程实例" class="headerlink" title="等待子进程实例"></a>等待子进程实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process is running.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process is waiting for the child to terminate.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 父进程等待子进程终止状态</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process collected child&#x27;s termination status.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，父进程创建了一个子进程，然后通过<code>wait(NULL)</code>等待子进程的终止状态。一旦子进程终止，父进程将收集子进程的终止状态。这确保了子进程不会变成僵尸进程。</p><p>要测试这个示例，可以将其编译为可执行文件，然后运行。当子进程终止时，父进程会收集其终止状态，然后打印相应的消息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc zombie_example.c -o zombie_example</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./zombie_example</span></span><br></pre></td></tr></table></figure><p>通过这个示例，可以清楚地看到父进程如何等待并处理子进程的终止状态，从而避免创建僵尸进程。</p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><h4 id="产生情景"><a href="#产生情景" class="headerlink" title="产生情景"></a><strong>产生情景</strong></h4><p>当一个父进程创建一个子进程，并且在子进程创建后，父进程意外终止（例如，父进程崩溃或被终止）而没有等待子进程完成时，这个子进程就会变成孤儿进程。这是因为父进程不再存在，没有能够等待子进程的机会。</p><h4 id="进程特点"><a href="#进程特点" class="headerlink" title="进程特点"></a><strong>进程特点</strong></h4><ul><li>孤儿进程的父进程ID（PPID）会被设置为1，这是<code>init</code>进程的进程ID。</li><li>孤儿进程继续在系统中运行，它们并不会受到父进程的终止影响。</li><li><code>Init</code>进程会成为孤儿进程的新父进程，它负责收养这些孤儿进程。</li><li><code>Init</code>进程会定期检查是否有子进程终止，如果有，它会调用<code>wait()</code>或<code>waitpid()</code>系统调用来回收子进程的资源和状态信息，防止子进程变成僵尸进程。</li></ul><h4 id="孤儿进程与僵尸进程的关系"><a href="#孤儿进程与僵尸进程的关系" class="headerlink" title="孤儿进程与僵尸进程的关系"></a><strong>孤儿进程与僵尸进程的关系</strong></h4><ul><li>孤儿进程不同于僵尸进程。孤儿进程是一个活跃的正在运行的子进程，而僵尸进程是已经终止但尚未被其父进程回收资源的子进程。</li><li>当一个孤儿进程终止并被<code>init</code>进程接管时，它最终会在其终止后被回收，不会成为僵尸进程。</li><li>僵尸进程通常是由于父进程没有正确回收子进程的状态信息而产生的，而孤儿进程则是因为父进程提前终止而没有机会回收子进程。</li></ul><blockquote><p>总之，孤儿进程是一种在父进程提前终止的情况下保证子进程继续运行并在适当时机被回收的机制。这有助于维护系统的稳定性和资源管理，避免了僵尸进程的问题。要注意的是，编写多进程的应用程序时，必须仔细处理子进程的创建和回收，以确保不会导致僵尸进程或其他问题。</p></blockquote><h4 id="进程实例"><a href="#进程实例" class="headerlink" title="进程实例"></a>进程实例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork(); <span class="comment">// 创建一个子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建子进程失败</span></span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child process (PID &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;) is running.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>); <span class="comment">// 子进程休眠一会儿</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child process (PID &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;) is done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent process (PID &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;) created a child process (PID &quot;</span> &lt;&lt; child_pid &lt;&lt; <span class="string">&quot;).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 不等待子进程完成</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent process (PID &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;) is done.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>&lt;sys/types.h&gt;</code>：<ul><li>功能：这个头文件包含了一些系统数据类型的定义，通常用于系统编程和与操作系统交互。</li><li>在函数中的使用：在程序中，<code>pid_t</code>数据类型的定义位于这个头文件中。<code>pid_t</code>用于表示进程ID（PID），在<code>fork()</code>函数的声明中使用了<code>pid_t</code>来表示子进程的PID。</li></ul></li><li><code>&lt;unistd.h&gt;</code>：<ul><li>功能：这个头文件包含了一些与Unix标准接口有关的常量和函数声明，通常用于系统编程和进程控制。</li><li>在函数中的使用：在程序中，<code>fork()</code>和<code>getpid()</code>等系统调用的声明位于这个头文件中。具体来说，<code>fork()</code>函数用于创建子进程，<code>getpid()</code>函数用于获取当前进程的PID。所以，<code>#include &lt;unistd.h&gt;</code> 允许你在程序中使用这些系统调用。</li></ul></li></ol><blockquote><p>总之，这段C++代码演示了通过<code>fork()</code>系统调用创建一个孤儿进程的过程。父进程创建子进程后，不等待子进程完成，因此子进程会在父进程终止后继续执行。这样，子进程就成为了孤儿进程，最终被init进程接管并在完成任务后终止。父进程则立即完成，不会等待子进程。</p></blockquote><h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><h4 id="优先级概念"><a href="#优先级概念" class="headerlink" title="优先级概念"></a>优先级概念</h4><blockquote><p>在Linux系统中，进程的优先级概念是关于进程调度和资源分配的重要概念。进程的优先级决定了它在系统中获得CPU时间的相对权重。在Linux中，优先级通常通过Nice值（也称为niceness）来表示，Nice值越低的进程拥有更高的优先级。</p></blockquote><h4 id="深入剖析"><a href="#深入剖析" class="headerlink" title="深入剖析"></a>深入剖析</h4><blockquote><p>Linux中的进程优先级是通过<strong>Nice值</strong>来控制的。Nice值是一个整数，<strong>通常范围从-20到19</strong>，其中-20表示最高优先级，而19表示最低优先级。较低的Nice值意味着更高的优先级，进程将更容易获得CPU时间片。</p></blockquote><p>以下是关于Linux进程优先级的详细信息：</p><ol><li><p><strong>Nice值的含义：</strong></p><ul><li><p><strong>较低的Nice值：</strong> 具有较低Nice值（通常为负数）的进程将被视为更重要，操作系统会更频繁地将CPU时间片分配给它们。这使得这些进程能够更快地执行任务。</p></li><li><p><strong>较高的Nice值：</strong> 具有较高Nice值（通常为正数）的进程被认为不太重要，操作系统会相对较少地将CPU时间片分配给它们。这意味着这些进程可能需要更长时间来完成其任务。</p></li></ul></li><li><p><strong>Nice值的设置和修改：</strong></p><ul><li><p><strong>设置初始Nice值：</strong> 在启动进程时，可以使用<code>nice</code>命令来设置其初始Nice值。例如，<code>nice -n 10 ./my_program</code>会启动一个进程并将其Nice值设置为10。</p></li><li><p><strong>修改Nice值：</strong> 在进程运行时，可以使用<code>renice</code>命令来修改进程的Nice值。<strong>管理员或进程所有者可以使用此命令来调整进程的优先级。</strong>例如，<code>renice -n 5 -p 12345</code>将进程ID为12345的进程的Nice值修改为5。</p></li></ul></li><li><p><strong>Nice值对系统性能的影响：</strong></p><ul><li><p>较低Nice值的进程更容易获得CPU时间，因此它们通常能够更快地响应用户请求或完成计算任务。</p></li><li><p>较高Nice值的进程通常会获得较少的CPU时间，这可能会导致它们的响应时间变长。这对于一些后台任务或低优先级任务是合适的。</p></li></ul></li><li><p><strong><code>CFS</code>调度算法：</strong></p></li></ol><ul><li><p>在Linux中，进程调度通常由Completely Fair Scheduler（CFS）算法管理。CFS的目标是公平地分配CPU时间，确保所有进程都有机会获得执行。</p></li><li><p>CFS使用Nice值来影响进程的调度优先级。较低Nice值的进程在调度时会被更频繁地选择执行，以确保它们获得更多的CPU时间。</p></li></ul><blockquote><p>总之，Nice值是Linux中控制进程优先级的关键概念。通过设置和调整Nice值，可以影响进程在系统中的相对优先级，从而<strong>优化系统性能和资源分配</strong>。在CFS调度算法下，Nice值对进程的调度优先级起着关键作用，确保公平而有效的资源分配。</p></blockquote><h4 id="实操解析"><a href="#实操解析" class="headerlink" title="实操解析"></a>实操解析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># ps -al</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  7663  7521  0  80   0 - 48519 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0  7689  7663  0  80   0 - 29217 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 R     0  7743  7689  0  80   0 - 38332 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><ol><li><p><strong>F（Flags）：</strong> 进程状态标志，通常表示进程的状态。在您的示例中，大多数进程的状态标志是”4 S”，这表示这些进程是处于睡眠（Sleep）状态。</p></li><li><p><strong>S（State）：</strong> 进程的状态，通常表示进程当前在何种状态下执行。在您的示例中，状态通常是”S”，表示进程正在运行。</p></li><li><p><strong>UID（User ID）：</strong> 进程的用户ID，标识进程所属的用户。在您的示例中，所有进程的用户ID都是0，表示root用户。</p></li><li><p><strong>PID（Process ID）：</strong> 进程的唯一标识符，用于在系统中识别和管理进程。</p></li><li><p><strong>PPID（Parent Process ID）：</strong> 父进程的PID，表示创建当前进程的父进程。在您的示例中，每个进程的PPID是其父进程的PID。</p></li><li><p><strong>C（CPU utilization）：</strong> 进程的CPU利用率，表示进程正在使用CPU的百分比。在您的示例中，CPU利用率都为0，表示这些进程当前没有使用CPU。</p></li><li><p><strong>PRI（Priority）：</strong> 进程的优先级，通常在0到139的范围内，其中较低的数值表示更高的优先级。在您的示例中，优先级都为80。</p></li><li><p><strong>NI（Nice Value）：</strong> 进程的Nice值，它是影响进程优先级的因素之一。较低的Nice值表示较高的优先级。在您的示例中，Nice值都为0，表示这些进程的Nice值未被显式设置。</p></li><li><p><strong>ADDR（Address）：</strong> 进程的内存地址。</p></li><li><p><strong>SZ（Size）：</strong> 进程的内存占用大小，以字节为单位。</p></li><li><p><strong>WCHAN（Wait Channel）：</strong> 进程正在等待的内核等待通道。在您的示例中，大多数进程的等待通道是”do_wai”，表示它们正在等待某些条件。</p></li><li><p><strong>TTY（Terminal Type）：</strong> 进程所关联的终端类型，如果没有关联终端，则显示”?”。</p></li><li><p><strong>TIME：</strong> 进程已经消耗的CPU时间。</p></li><li><p><strong>CMD（Command）：</strong> 正在运行的进程的命令行。</p></li></ol><p>根据示例，列出了一些正在运行的进程，它们的优先级（PRI）都为80，Nice值（NI）都为0，表示它们在调度时具有<strong>默认优先级</strong>。这些进程的CPU利用率（C）都为0，表示它们当前没有在使用CPU。进程的状态（S）为”Sleep”或”Running”，并且<strong>它们的终端类型（TTY）显示为”pts/0”，表示它们与一个终端会话关联。</strong></p><h5 id="pst-0"><a href="#pst-0" class="headerlink" title="pst/0"></a><code>pst/0</code></h5><blockquote><p>“pts/0” 表示伪终端（pseudo-terminal slave）的名称，它表示一个终端会话的名称。在Linux系统中，终端会话是用户与系统交互的一种方式，允许他们在终端上运行命令和程序。</p></blockquote><ul><li><p><strong>pts（pseudo-terminal slave）：</strong> “pts” 表示伪终端从属端口，它通常用于远程登录或在图形用户界面（GUI）中打开终端窗口。每当用户在终端窗口中登录或打开一个新的终端会话时，系统会分配一个唯一的 “pts” 名称。</p></li><li><p><strong>0：</strong> “0” 表示终端会话的序号，通常从0开始递增，以标识不同的终端会话。如果系统上有多个终端会话，每个会话都会有一个唯一的 “pts” 名称和序号。</p></li></ul><blockquote><p>因此，”pts/0” 表示第一个伪终端从属端口，它与用户的一个终端会话相关联。这是一个用户在命令行终端中运行命令的地方，用户可以在其中输入命令并查看输出。在多用户系统上，每个用户登录时都会分配一个独立的终端会话（通常对应一个 “pts” 名称），使他们可以并行执行命令和任务。</p></blockquote><h5 id="bash与pst-0"><a href="#bash与pst-0" class="headerlink" title="bash与pst/0"></a><code>bash</code>与<code>pst/0</code></h5><p>Bash（Bourne Again Shell）是一种Unix shell，用于在终端或终端仿真器中与操作系统进行交互。伪终端（pseudo-terminal，通常缩写为pts）则是一种用于在Unix系统中提供终端会话的机制。</p><p>Bash 和伪终端之间的关系是，Bash 是用户在终端或伪终端中输入命令并与操作系统进行交互的主要方式之一。以下是它们之间的关系：</p><ol><li><p><strong>Bash 在终端中运行：</strong> 当您在终端中打开一个新的终端会话时，例如通过SSH登录远程服务器或在本地计算机的终端窗口中运行，通常会创建一个伪终端。然后，系统将Bash shell启动在这个伪终端中，用户可以使用Bash shell与系统进行交互。</p></li><li><p><strong>Bash 处理用户输入和命令执行：</strong> 在Bash shell中，用户可以输入各种命令、执行程序、导航文件系统等等。Bash负责解释和执行这些命令，同时还允许用户与操作系统进行通信。</p></li><li><p><strong>伪终端提供终端会话：</strong> 伪终端是一种机制，用于模拟物理终端，允许用户通过终端会话与操作系统进行交互。当Bash在终端中运行时，它实际上是在伪终端中运行，用户的输入和输出都经过这个伪终端传递。</p></li><li><p><strong>Bash 和伪终端的关系：</strong> <strong>Bash shell和伪终端之间是一种客户端-服务器关系。</strong>Bash充当终端会话的客户端，而伪终端充当服务器，负责处理输入和输出。当用户在终端中键入命令时，Bash将命令发送到伪终端，伪终端执行命令并将结果返回给Bash，然后Bash将结果显示在终端上，以便用户查看。</p></li></ol><blockquote><p>综上所述，Bash是用户与系统进行交互的shell，而伪终端是在Unix系统中提供终端会话的机制。Bash运行在伪终端中，用户通过Bash来执行命令并与操作系统互动。因此，Bash和伪终端密切相关，共同实现了在终端窗口中运行命令的功能。</p></blockquote><h5 id="调整优先级"><a href="#调整优先级" class="headerlink" title="调整优先级"></a>调整优先级</h5><p><strong><code>nice</code> 命令：</strong></p><ul><li><p><code>nice</code> 命令用于启动新进程并设置其初始优先级。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> -n &lt;优先级&gt; &lt;命令&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;优先级&gt;</code> 是一个整数，通常范围从-20（最高优先级）到19（最低优先级），较低的值表示较高的优先级。</li><li><code>&lt;命令&gt;</code> 是要运行的命令。例如，要以较高优先级运行一个命令，可以使用以下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> -n -10 ./my_command</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>renice</code> 命令：</strong></p><ul><li><p><code>renice</code> 命令用于修改正在运行的进程的优先级。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -n &lt;新的优先级&gt; -p &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;新的优先级&gt;</code> 是要设置的新优先级。</li><li><code>&lt;进程ID&gt;</code> 是要调整优先级的进程的进程ID。例如，要将进程ID为12345的进程的优先级提高到较高的水平，可以使用以下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice -n -10 -p 12345</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>taskset</code> 命令：</strong></p><ul><li><p><code>taskset</code> 命令用于将进程绑定到特定的 CPU 核心，并可以在命令中设置优先级。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c &lt;CPU核心列表&gt; <span class="built_in">nice</span> -n &lt;优先级&gt; &lt;命令&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&lt;CPU核心列表&gt;</code> 是要绑定进程到的 CPU 核心列表。</li><li><code>&lt;优先级&gt;</code> 是要设置的新优先级。</li><li><code>&lt;命令&gt;</code> 是要运行的命令。</li></ul><p>例如，要将一个命令运行在 CPU 核心0上并设置其优先级，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -c 0 <span class="built_in">nice</span> -n -10 ./my_command</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>top</code>命令：</strong></p><p>在 <code>top</code> 中，不能直接修改进程的优先级（Nice值），但可以使用 <code>top</code> 提供的快捷键来调整进程的优先级。</p><p>以下是如何在 <code>top</code> 中改变进程优先级的步骤：</p><ol><li><p>打开终端窗口并运行 <code>top</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure></li><li><p>在 <code>top</code> 窗口中，将看到系统上运行的进程列表以及系统性能的实时统计信息。</p></li><li><p>使用上下箭头键浏览进程列表，找到想要调整优先级的进程。注意进程的 PID（进程ID）。</p></li><li><p>选中要调整优先级的进程。为了选中进程，请按下<code>&quot;r&quot;</code>，输入进程PID。</p></li><li><p>您将看到一个弹出窗口，提示您输入新的 Nice 值。较低的 Nice 值表示较高的优先级。</p></li><li><p>输入您希望设置的新 Nice 值。</p></li><li><p>按下 Enter 键，确认更改。</p></li><li><p><code>top</code> 会将新的 Nice 值应用于选中的进程，并在进程列表中更新。</p></li></ol><p>请注意，这个操作需要足够的权限来改变进程的优先级。通常，只有超级用户（root）或具有适当权限的用户可以执行这个操作。如果您没有足够的权限，您可能需要使用 <code>sudo</code> 命令以超级用户权限运行 <code>top</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo top</span><br></pre></td></tr></table></figure><p>这样，就可以在 <code>top</code> 中调整进程的优先级。确保在调整进程优先级时谨慎操作，以免影响系统的正常运行。</p><h5 id="优先级计算"><a href="#优先级计算" class="headerlink" title="优先级计算"></a>优先级计算</h5><p>在Unix/Linux操作系统中，进程的优先级通常通过Nice Value（NI）来表示，以及调度优先级也可以通过PRI（Priority）来表示。以下是有关这两个概念的详细信息：</p><ol><li><p><strong>Nice Value (NI) - 优先级调整</strong>：</p><ul><li>NI（Nice Value）是一个整数值，通常在-20到19之间。</li><li>一个更高的NI值表示进程更<strong>“友好”</strong>，<strong>更愿意让出CPU时间片给其他进程</strong>，因此它降低了进程的优先级。</li><li>一个较低的NI值表示进程更<strong>“不友好”</strong>，<strong>更愿意占用CPU时间片</strong>，因此它提高了进程的优先级。</li><li>可以使用<code>nice</code>命令来调整进程的NI值，只有root用户可以将NI值设置为负数，即提高进程的优先级。</li></ul></li><li><p><strong>优先级计算</strong>：</p><ul><li><p>优先级计算的具体方法可以因不同的Unix/Linux变种而异，但一般而言，进程的优先级可以通过以下方式计算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程优先级 = 基本优先级 (PRI) + NI (Nice Value)</span><br></pre></td></tr></table></figure></li><li><p>基本优先级（PRI）通常在不同的系统中有不同的范围，但一般来说，它是一个整数值，表示进程的基本调度优先级。</p></li><li>NI值可以为正数或负数，正数表示较低的优先级，负数表示较高的优先级。通常，系统将0作为默认NI值。</li></ul></li></ol><blockquote><p>总之，要计算一个进程的最终优先级，只需将其<strong>基本优先级（PRI）和Nice Value（NI）相加即可</strong>。如果NI值为正数，那么将降低进程的优先级，如果NI值为负数，那么将提高进程的优先级。但请注意，优先级的具体计算方法可能因不同的Unix/Linux系统而异，可以查阅相关文档以了解系统的详细规则。</p></blockquote><h1 id="小问杂谈"><a href="#小问杂谈" class="headerlink" title="小问杂谈"></a>小问杂谈</h1><h2 id="程序调用sleep是什么状态"><a href="#程序调用sleep是什么状态" class="headerlink" title="程序调用sleep是什么状态"></a>程序调用sleep是什么状态</h2><p>当一个程序调用 <code>sleep</code> 函数时，它的进程状态会经历以下状态变化：</p><ol><li><strong>运行态 (Running)</strong>：在调用 <code>sleep</code> 函数之前，进程通常处于运行状态。这意味着它正在占用CPU执行任务。</li><li><strong>系统调用 (System Call)</strong>：当程序调用 <code>sleep</code> 函数时，它会发起一个系统调用，请求操作系统将其置于睡眠状态并设置一个定时器，以便在一定时间后唤醒它。</li><li><strong>睡眠态 (Sleeping)</strong>：一旦系统调用生效，进程状态会从 “运行态” 转变为 “睡眠态”。这表示进程现在处于休眠状态，不再占用CPU时间。同时，操作系统会设置一个定时器，以计算进程需要休眠多长时间。</li><li><strong>等待时间</strong>：在 “睡眠态” 期间，进程会等待指定的时间（即 <code>sleep</code> 函数参数中指定的时间）。这个时间可以是秒数、毫秒数或其他时间单位，取决于系统和 <code>sleep</code> 函数的具体实现。</li><li><strong>唤醒 (Wake-up)</strong>：当休眠时间到期后，定时器会触发，操作系统将进程从睡眠状态唤醒，并将其置于 “就绪态 (Ready)”。此时，进程已经休眠了指定的时间，并准备好继续执行。</li><li><strong>就绪态 (Ready)</strong>：一旦进程被唤醒，它进入 “就绪态”，等待操作系统的调度器将其分配到CPU上执行。从 “就绪态” 到 “运行态” 的转换取决于操作系统的调度算法和系统负载情况。</li></ol><blockquote><p>总之，调用 <code>sleep</code> 函数会导致进程从 “运行态” 转变为 “睡眠态”，然后在指定的时间后重新进入 “就绪态”，以便继续执行。这种机制允许程序在需要休眠一段时间而不占用 CPU 时间的情况下继续执行其他任务。</p><p>需要注意的是，虽然进程在 <code>sleep</code> 期间处于睡眠状态，但这并不意味着它会阻塞整个系统。其他进程仍然可以继续执行，因为操作系统会根据进程的状态和调度策略来分配CPU时间片。当 <code>sleep</code> 时间到期后，进程将被重新置于就绪状态，然后根据调度算法等待获取CPU时间，再次执行其任务。</p></blockquote><h2 id="进程处于暂停状态位于什么队列"><a href="#进程处于暂停状态位于什么队列" class="headerlink" title="进程处于暂停状态位于什么队列"></a>进程处于暂停状态位于什么队列</h2><p>在Linux中，当一个进程处于暂停状态（Stopped），它通常会进入内核中的一个特殊队列，称为<strong>停止队列（Stopped Queue）</strong>，也可以称为<strong>终止队列（Terminated Queue）</strong>。这个队列用于管理已经被明确停止或暂停的进程，以便稍后可以对它们进行操作或管理。</p><p>下面是停止队列的详细解释：</p><ol><li><p><strong>停止状态（Stopped）</strong>：当一个进程被明确停止，例如通过发送SIGSTOP信号或执行类似的操作，它的状态从 “运行态 (Running)” 或其他状态转变为 “停止态 (Stopped)”。</p></li><li><p><strong>进入停止队列</strong>：一旦进程被停止，它会从运行队列中移除，并被放入停止队列中。在停止队列中，操作系统会维护进程的状态信息和其他相关信息。</p></li><li><p><strong>等待操作或管理</strong>：在停止队列中，进程会等待进一步的操作或管理。通常情况下，这些操作由进程的父进程或其他管理机制来执行。例如，父进程可以选择继续执行已停止的子进程，终止子进程或执行其他管理任务。</p></li><li><p><strong>重新启动或终止</strong>：根据管理操作，进程可以被重新启动，继续执行其任务，或者被终止，彻底结束其生命周期。这取决于父进程或管理者的决策。</p></li></ol><blockquote><p>停止队列的存在使操作系统能够有效地管理已停止的进程，以便稍后执行必要的操作。这对于进程的控制和管理非常有用，例如在调试和监控方面，允许用户或系统管理员对进程进行适当的操作，而不会丢失进程的状态信息。</p></blockquote><h2 id="Linux中没有挂起状态吗"><a href="#Linux中没有挂起状态吗" class="headerlink" title="Linux中没有挂起状态吗"></a>Linux中没有挂起状态吗</h2><p>在Linux中，没有一个专门称为”挂起状态”（Suspend State）的进程状态，与其他一些操作系统（如Windows）不同，Linux将进程状态分为了不同的状态，包括运行状态、可中断睡眠状态、不可中断睡眠状态等，而没有单独的”挂起状态”。</p><p>以下是Linux中常见的进程状态：</p><ol><li><p><strong>运行状态（Running）</strong>：表示进程当前正在执行指令，并且占用CPU时间。</p></li><li><p><strong>可中断睡眠状态（Interruptible Sleep）</strong>：表示进程正在等待某些事件的发生，例如等待用户输入或等待网络数据到达。这种状态下，进程可以被中断，以响应中断或其他事件。</p></li><li><p><strong>不可中断睡眠状态（Uninterruptible Sleep）</strong>：表示进程正在等待某些不可中断的事件或资源，通常是底层硬件资源或内核操作，例如等待磁盘I/O完成。这种状态下，进程是不可中断的，不能被正常终止。</p></li><li><p><strong>僵尸状态（Zombie）</strong>：表示进程已经终止，但其父进程还没有读取到其终止状态。这种状态通常是由于父进程没有正确地等待或处理其子进程的终止状态而导致的。</p></li><li><p><strong>终止状态（Terminated）</strong>：表示进程已经终止并且不再运行。</p></li></ol><p>“挂起状态”通常在某些桌面操作系统中用于指代进程暂停执行，以便稍后继续执行。在Linux中，进程的暂停和继续通常通过<code>SIGSTOP</code>和<code>SIGCONT</code>信号来实现，而不会有一个单独的状态来表示”挂起”。<code>SIGSTOP</code>信号用于暂停进程，<code>SIGCONT</code>信号用于继续进程的执行。</p><p>要将进程挂起，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -STOP &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><p>要继续挂起的进程，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -CONT &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><p>总之，虽然Linux中没有一个单独的”挂起状态”，但可以通过<code>SIGSTOP</code>和<code>SIGCONT</code>信号来实现进程的挂起和继续操作。进程状态在Linux中通常包括运行状态、可中断睡眠状态、不可中断睡眠状态等，以反映进程的当前情况。</p><h2 id="何时会把进程数据交换到外存"><a href="#何时会把进程数据交换到外存" class="headerlink" title="何时会把进程数据交换到外存"></a>何时会把进程数据交换到外存</h2><p>Linux会在以下情况下将进程的数据交换到外部存储（通常是硬盘）：</p><ol><li><p><strong>内存不足：</strong> 当系统内存不足以容纳当前正在运行的进程所需的数据时，Linux会将一些进程的数据交换到硬盘上的交换分区（swap partition）或交换文件（swap file）中，以释放物理内存供其他进程使用。这是Linux内存管理的一部分，用于避免内存耗尽的情况。</p></li><li><p><strong>页面置换：</strong> Linux使用页面置换算法来决定哪些页面（内存中的数据块）将被交换到外部存储器中。常见的页面置换算法包括最近未使用（<code>LRU</code>）和最不常用（<code>LFU</code>）等。当需要更多内存来运行新进程或满足当前活动进程的内存需求时，系统会选择一些页面进行交换。</p></li><li><p><strong>进程休眠：</strong> 当进程处于休眠状态（可中断或不可中断睡眠状态）时，它的数据可能会被交换出内存，以释放内存资源供其他活跃进程使用。一旦进程再次被唤醒，它的数据将从交换空间还原到内存中。</p></li><li><p><strong>内存压力：</strong> 当系统面临内存压力（内存用尽或接近用尽）时，Linux会主动开始将部分进程的数据交换到外部存储，以维持系统的稳定性。这有助于防止系统因内存不足而崩溃或变得不响应。</p></li><li><p><strong>交换分区的设置：</strong>系统管理员可以配置交换分区的大小，以影响系统交换的频率和程度。合适的交换空间大小取决于系统的需求和硬件资源。通常，建议交换分区的大小至少等于系统内存的1.5倍，但这也取决于具体情况。</p></li></ol><blockquote><p>虽然交换可以避免内存耗尽问题，但频繁的交换操作会对系统性能产生负面影响，因为硬盘访问速度比内存慢得多。这可能导致进程响应时间变长，系统变得不够流畅。因此，为了避免过多的交换操作，建议在物理内存上提供足够的内存资源。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Linux』进程代码初识</title>
      <link href="/2023/09/22/%E3%80%8ELinux%E3%80%8F%E8%BF%9B%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%88%9D%E8%AF%86/"/>
      <url>/2023/09/22/%E3%80%8ELinux%E3%80%8F%E8%BF%9B%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程代码初识"><a href="#进程代码初识" class="headerlink" title="进程代码初识"></a>进程代码初识</h1><h2 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a><code>proc.c</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m a process!\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<code>#include &lt;stdio.h&gt;</code> 和 <code>#include &lt;unistd.h&gt;</code>：这两行是C语言的预处理指令，它们告诉编译器在编译程序之前将标准输入输出库（<code>stdio.h</code>）和<strong>Unix系统调用库</strong>。</p><p>2.<code>sleep(1);</code>：这是一个<strong>系统调用</strong>，它使进程休眠1秒钟。也就是说，每次循环执行后，程序会休眠1秒钟，然后再次执行循环。</p><blockquote><p>这个程序是一个简单的无限循环，每秒打印一次”I’m a process!”，并在每次打印后休眠1秒钟。这可以用于演示一个运行中的进程，它以1秒的间隔输出一条消息。如果要终止程序，您可以手动中断它，例如按下<code>Ctrl+C</code>。</p></blockquote><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a><code>Makefile</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc:proc.c </span><br><span class="line">gcc -o proc proc.c</span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line"><span class="built_in">rm</span> -f proc</span><br></pre></td></tr></table></figure><ol><li><code>proc: proc.c</code>：这一行指示Make工具如何构建目标”proc”。它告诉Make工具，要生成目标”proc”，它依赖于”proc.c”文件。如果”proc.c”文件发生了变化，Make工具将重新编译”proc”目标。</li><li><code>gcc -o proc proc.c</code>：这是实际的编译命令。它告诉<code>gcc</code>编译器将”proc.c”源文件编译成一个可执行文件，文件名为”proc”。”-o”选项用于指定输出文件的名称。</li><li><code>.PHONY: clean</code>：这一行定义了一个伪目标，即”clean”。伪目标通常用于执行一些特殊的任务，而不是生成文件。在这种情况下，它用于清理生成的可执行文件。</li><li><code>clean:</code>：这一行表示”clean”目标的开始。它告诉Make工具，下面的命令将执行”clean”操作。</li><li><code>rm -f proc</code>：这是”clean”目标的命令部分。它使用<code>rm</code>命令来删除名为”proc”的文件。<code>-f</code>选项告诉<code>rm</code>命令在文件不存在时不报错，以避免出现错误消息。这个命令的效果是删除生成的可执行文件。</li></ol><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>上述的Makefile文件本身并不产生输出，它用于编译和清理程序。要执行该Makefile文件并生成可执行文件，请按照以下步骤进行操作：</p><ol><li>创建一个名为<code>proc.c</code>的C源代码文件，将其中的内容设置之前提供的程序代码。</li><li>在同一目录下创建一个名为<code>Makefile</code>的文件，并将其内容设置为您之前提供的Makefile代码。</li><li>打开终端，并导航到包含<code>proc.c</code>和<code>Makefile</code>的目录。</li><li>执行以下命令以编译程序：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>这将使用Makefile中的规则来编译<code>proc.c</code>并生成可执行文件<code>proc</code>。</p><ol><li>一旦编译完成，您可以运行生成的可执行文件<code>proc</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./proc</span><br></pre></td></tr></table></figure><p>这将启动程序，它会每秒输出一次”I’m a process!”，并<strong>无限循环运行</strong>。</p><p>如果您想要清理生成的可执行文件，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><p>这将删除名为<code>proc</code>的可执行文件。</p><p>请注意，<strong>输出将在终端上显示</strong>，以每秒一次的频率打印”I’m a process!”。要停止程序的运行，您可以在终端中按下<code>Ctrl+C</code>来中断它。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://image-somn.oss-cn-beijing.aliyuncs.com/proc.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axj | <span class="built_in">head</span> -1 &amp;&amp; ps axj | grep proc | grep -v grep</span><br></pre></td></tr></table></figure><ol><li><code>ps axj | head -1</code>：这部分命令首先运行<code>ps axj</code>，它用于显示所有进程的详细信息。然后，通过管道<code>|</code>将其输出传递给<code>head -1</code>，<code>head</code>命令用于显示输出的前几行，<code>-1</code>表示只显示第一行，即进程表的标题行。</li><li><code>&amp;&amp;</code>：这是逻辑操作符，用于在前一个命令成功执行后才执行下一个命令。</li><li><code>ps axj | grep proc | grep -v grep</code>：这部分命令运行<code>ps axj</code>以获取进程列表，然后通过两次<code>grep</code>过滤出包含关键字”proc”的进程。具体来说：<ul><li>第一个<code>grep</code>命令<code>grep proc</code>用于筛选包含”proc”关键字的行。</li><li>第二个<code>grep</code>命令<code>grep -v grep</code>用于排除包含”grep”关键字的行，以避免匹配到自身的<code>grep</code>进程。</li></ul></li></ol><blockquote><p>最终的输出显示了进程列表中包含关键字”proc”的进程信息，包括它们的父进程ID（PPID）、进程ID（PID）、进程组ID（PGID）、会话ID（SID）、终端（TTY）、终端进程组ID（TPGID）、状态（STAT）、用户ID（UID）、累计CPU时间（TIME）和命令（COMMAND）。</p></blockquote><p>根据输出，可以看到一个进程具有PID 24055，它是通过执行<code>./proc</code>命令启动的。</p><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 24055 //24055为上述查询到的进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>执行<code>kill -9 24055</code>命令会发送一个<strong>强制终止信号（SIGKILL）</strong>给进程PID为24055的进程。这会立即终止该进程，而不会给予它进行清理或保存数据的机会。</p><p>请注意，使用<code>kill -9</code>是一种强制终止进程的方法，应该小心使用，因为它不允许进程进行善后工作。只有在有必要时才应该使用这种信号，例如当一个进程不响应其他终止信号并且必须立即停止时。</p><p>在执行<code>kill -9 24055</code>后，进程PID 24055将被终止，不再运行。<strong>如果需要终止其他进程，请将其PID替换为所需的PID</strong>。</p><h1 id="系统调用初识"><a href="#系统调用初识" class="headerlink" title="系统调用初识"></a>系统调用初识</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m a process! My pid:%d\n&quot;</span>, getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>#include &lt;unistd.h&gt;</code>：这是包含Unix标准库的预处理指令，其中包含了sleep函数，用于在程序中添加延迟。</li><li><code>#include &lt;unistd.h&gt;</code>：这是包含Unix标准库的预处理指令，其中包含了 <code>getpid()</code> 函数和 <code>sleep()</code> 函数的声明。</li><li><code>printf(&quot;I&#39;m a process! My pid:%d\n&quot;, getpid());</code>：这是一个输出语句，用于在终端上打印一条消息。<code>getpid()</code>函数用于获取当前进程的进程ID（PID），并将其插入到消息中。</li></ol><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><img src="https://image-somn.oss-cn-beijing.aliyuncs.com/%E5%88%9D%E8%AF%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt=""></p><h2 id="getpid"><a href="#getpid" class="headerlink" title="getpid()"></a><code>getpid()</code></h2><blockquote><p><code>getpid()</code> 是一个C标准库函数，通常用于获取当前进程的进程ID（PID）。PID是一个唯一标识运行中进程的正整数值。</p></blockquote><p>以下是对<code>getpid()</code>函数和示例程序的详细解释：</p><ol><li>包含头文件：为了使用<code>getpid()</code>函数，首先需要包含合适的头文件。通常，我们会包含 <code>&lt;unistd.h&gt;</code> 头文件，因为该头文件包含了<code>getpid()</code>函数的声明。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><ol><li>声明变量：在示例程序中，我们声明了一个名为<code>pid</code>的变量，其类型是 <code>pid_t</code>。<code>pid_t</code> 是一个数据类型，通常用于表示进程ID。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid;</span><br></pre></td></tr></table></figure><ol><li>使用<code>getpid()</code>函数：接下来，我们使用<code>getpid()</code>函数来获取当前进程的PID，并将其存储在<code>pid</code>变量中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid = getpid();</span><br></pre></td></tr></table></figure><ol><li>打印PID：最后，我们使用<code>printf</code>函数将获取到的PID打印到终端上，以便查看。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My PID is: %d\n&quot;</span>, pid);</span><br></pre></td></tr></table></figure><p>示例程序中的完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = getpid();  <span class="comment">// 获取当前进程的PID</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My PID is: %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您运行这个程序时，它会执行以下操作：</p><ol><li>调用<code>getpid()</code>函数，该函数返回当前进程的PID，并将其存储在<code>pid</code>变量中。</li><li>使用<code>printf</code>函数将获取到的PID打印到终端上，形成一条类似 “My PID is: 12345” 的输出，其中12345是当前进程的实际PID。</li><li>然后，程序返回0作为退出状态码，表明程序正常退出。</li></ol><p>通过这个示例程序，可以获得当前运行进程的PID，这在许多进程管理和通信场景中非常有用。每个运行的进程都有一个唯一的PID，允许操作系统和其他程序识别和管理它们。</p><h2 id="getppid"><a href="#getppid" class="headerlink" title="getppid()"></a><code>getppid()</code></h2><blockquote><p><code>getppid</code> 函数用于获取当前进程的父进程的进程ID（PID）。后续与<code>fork()</code>函数一起讲解。</p></blockquote><ol><li><p><strong>返回类型</strong>：<code>getppid</code> 函数返回一个 <code>pid_t</code> 类型的整数，表示父进程的PID。<code>pid_t</code> 是一个有符号整数类型，通常用于表示进程ID。</p></li><li><p><strong>用途</strong>：主要用于进程间通信和进程控制的场景，它允许一个进程获取其父进程的PID。这在一些编程任务中非常有用，如父子进程之间的协作或监视。</p></li><li><p><strong>父进程</strong>：父进程是启动当前进程的进程。<strong>在典型情况下，父进程是终端 shell 进程，因为终端 shell 通常是用户启动程序的方式。</strong>但也可以通过其他方式启动进程（例如创建子进程），因此父进程可能不仅仅是终端 shell。</p></li><li><p><strong>使用示例</strong>：下面是一个使用 <code>getppid</code> 函数的示例程序，它获取当前进程的父进程的PID并输出到标准输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> parent_pid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;My parent&#x27;s PID: %d\n&quot;</span>, parent_pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序将输出当前进程的父进程的PID。</p></li><li><p><strong>常见场景</strong>：<code>getppid</code> 函数在编写守护进程、进程间通信、子进程创建和控制等任务中常常被使用。它允许进程在运行时获取有关其父进程的信息，以便执行不同的操作，例如向父进程报告状态或请求资源。</p></li></ol><p>总之，<code>getppid</code> 函数是一个用于获取父进程PID的系统调用，可以用于进程间的信息交流和控制。它允许一个进程了解其创建者或启动者，并在需要时与之进行交互。</p><h1 id="查看进程方式"><a href="#查看进程方式" class="headerlink" title="查看进程方式"></a>查看进程方式</h1><p>当需要查看进程时，可以使用以下命令和方法来获取详细信息：</p><ol><li><strong><code>ps</code>命令</strong>：<code>ps</code>命令用于列出当前终端会话中的进程。您可以使用不同的选项来获取不同层次的信息：<ul><li><code>ps aux</code>：显示所有用户的所有进程的详细信息，包括进程ID（PID）、CPU使用率、内存使用等。</li><li><code>ps -ef</code>：类似于<code>ps aux</code>，也会列出所有用户的所有进程。</li><li><code>ps -e | grep process_name</code>：通过进程名称查找特定进程。</li><li><code>ps axj</code>：显示进程的详细信息，包括父进程ID（PPID）、进程组ID（PGID）、会话ID（SID）、终端、状态、用户ID（UID）、运行时间、命令等</li></ul></li><li><strong>top命令</strong>：<code>top</code>命令提供实时的进程监视和系统性能信息。启动<code>top</code>后，您可以看到进程列表以及CPU、内存等资源使用情况。按键盘上的不同键可以对进程列表进行排序和筛选，例如按<code>P</code>键按CPU使用率排序，按<code>M</code>键按内存使用率排序。</li><li><strong>htop命令</strong>：<code>htop</code>是<code>top</code>的交互式版本，提供更多功能和可视化选项。它使用颜色和更直观的界面来显示进程信息，还允许您通过鼠标或键盘进行交互式操作。</li><li><strong>pgrep命令</strong>：<code>pgrep</code>命令用于根据进程名称查找进程ID（PID）。例如，<code>pgrep firefox</code>将返回所有名为 “firefox” 的进程的PID。</li><li><strong>/proc文件系统</strong>：Linux系统中的<code>/proc</code>文件系统包含了有关系统中运行的进程的详细信息。您可以使用文件浏览器或命令行来查看<code>/proc</code>目录中的进程信息。每个进程都有一个以其PID命名的目录，其中包含有关该进程的各种文件，例如<code>/proc/PID/status</code>包含了进程的状态信息。</li></ol><blockquote><p>这些方法可以根据您的需求选择使用，以获取有关正在运行的进程的详细信息。通常，<code>ps</code>、<code>top</code>和<code>htop</code>是最常用的工具，而<code>pgrep</code>和<code>/proc</code>文件系统可以用于更具体的任务。</p></blockquote><h1 id="fork-初识"><a href="#fork-初识" class="headerlink" title="fork()初识"></a><code>fork()</code>初识</h1><p><code>fork</code> 函数是一个用于创建新进程的系统调用，它在Unix-like操作系统中非常常见。以下是对 <code>fork</code> 函数的详细解释：</p><ol><li><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>fork</code> 函数返回一个 <code>pid_t</code> 类型的值，表示新进程的PID。<strong>在父进程中，返回新进程的PID；在子进程中，返回0；如果出现错误，返回-1。</strong></li></ul></li><li><p><strong>功能</strong>：</p><ul><li>当调用 <code>fork</code> 函数时，操作系统会创建一个新的进程，新进程是调用进程（父进程）的副本。父进程和子进程将在之后的执行中独立运行，彼此不会相互影响。</li><li>父进程和子进程之间的主要区别在于返回值：父进程接收子进程的PID，而子进程接收0作为返回值，这样可以通过返回值来区分两者。</li><li>子进程继承了父进程的大部分属性，包括代码、数据、文件描述符、环境变量等，但它们之间的资源（如文件描述符的位置、内存映射等）是独立的，不会相互干扰，会发生写诗拷贝。</li></ul></li><li><p><strong>用途</strong>：</p><ul><li>创建多进程程序，同时执行不同的任务。</li><li>在服务器应用中，父进程通常用于接受客户端连接，而子进程用于处理每个客户端的请求。</li><li>在一些情况下，<code>fork</code> 用于实现并行计算，将工作分配给多个子进程以提高性能。</li></ul></li><li><p><strong>示例</strong>： 下面是一个示例程序，演示如何使用 <code>fork</code> 函数创建一个子进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程代码</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child: My PID=%d, My parent&#x27;s PID=%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">3</span>); <span class="comment">// 可以添加适当的延迟，以控制打印速率</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程代码</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent: My PID=%d, My parent&#x27;s PID=%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">3</span>); <span class="comment">// 可以添加适当的延迟，以控制打印速率</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述示例中，父进程调用 <code>fork</code> 创建了一个子进程，父子进程会分别输出不同的消息，同时打印自己的PID。</p></li></ol><blockquote><p>总之，<code>fork</code> 函数是一个关键的系统调用，用于创建新进程，使其在独立的执行环境中运行。它是多进程编程的基础，并在Unix-like操作系统中广泛使用。</p></blockquote><h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><p><img src="https://image-somn.oss-cn-beijing.aliyuncs.com/fork.png" alt=""></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><blockquote><p>从实验结果可以看出，此时父子进程同时运行并在控制台输出父子进程id。同时右侧通过指令显示当前实验运行的进程的相关信息与左边输出结果形成对应。</p><p>父进程通过<code>fork</code>函数的返回值可以获取成功创建的子进程id，同时给子进程返回0。</p></blockquote><p><code>-bash</code> 是一个命令行终端的名称，它表示一个交互式的 <strong>Bash Shell 会话</strong>。这是一个用于与操作系统交互的命令行界面，用户可以在其中执行各种命令和操作。</p><p>在此输出中，<code>16856</code> 是一个进程的PID，它是Bash Shell的父进程。</p><p>具体来说，<code>16856</code> 是当前终端会话（<code>pts/2</code>）的父进程的PID。在这个终端会话中，<code>16857</code> 是Bash Shell的PID，而<code>16856</code> 是启动了这个Bash Shell会话的进程的PID。</p><p>通常情况下，Bash Shell的父进程是终端程序，它负责启动并管理终端会话。在这里，<code>16856</code> 表示终端程序，而 <code>16857</code> 表示Bash Shell。 Bash Shell 是用户在终端中输入命令并与系统交互的主要界面，而终端程序负责管理这个终端会话。</p><p>在Bash Shell中，用户可以输入命令来执行各种操作，例如文件操作、进程管理、软件安装等。Shell是与操作系统交互的主要界面之一，它允许用户以文本方式与计算机进行通信和控制。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Cpp』入门指南</title>
      <link href="/2023/09/18/%E3%80%8ECpp%E3%80%8F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2023/09/18/%E3%80%8ECpp%E3%80%8F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-入门指南：关键字、命名空间和现代特性的简介"><a href="#C-入门指南：关键字、命名空间和现代特性的简介" class="headerlink" title="C++入门指南：关键字、命名空间和现代特性的简介"></a>C++入门指南：关键字、命名空间和现代特性的简介</h1><h2 id="1、关键字"><a href="#1、关键字" class="headerlink" title="1、关键字"></a>1、关键字</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>C++总计<strong>63</strong>个关键字，C语言<strong>32</strong>个关键字。</p><p>C++关键字是一组由C++语言定义的具有特殊含义的保留字。这些关键字在C++编程中具有特殊的用途，不能用作标识符或变量名。</p><h3 id="1-2-列表"><a href="#1-2-列表" class="headerlink" title="1.2 列表"></a>1.2 列表</h3><p>此处仅对C++关键字进行展示，此后会对其进行详细解释。</p><div class="table-container"><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">关键字</th><th style="text-align:center">关键字</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">alignas</td><td style="text-align:center">alignof</td><td style="text-align:center">and</td><td style="text-align:center">and_eq</td></tr><tr><td style="text-align:center">asm</td><td style="text-align:center">auto</td><td style="text-align:center">bitand</td><td style="text-align:center">bitor</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">break</td><td style="text-align:center">case</td><td style="text-align:center">catch</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">char8_t</td><td style="text-align:center">char16_t</td><td style="text-align:center">char32_t</td></tr><tr><td style="text-align:center">class</td><td style="text-align:center">compl</td><td style="text-align:center">concept</td><td style="text-align:center">const</td></tr><tr><td style="text-align:center">consteval</td><td style="text-align:center">constexpr</td><td style="text-align:center">const_cast</td><td style="text-align:center">continue</td></tr><tr><td style="text-align:center">co_await</td><td style="text-align:center">co_return</td><td style="text-align:center">co_yield</td><td style="text-align:center">decltype</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">delete</td><td style="text-align:center">do</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">dynamic_cast</td><td style="text-align:center">else</td><td style="text-align:center">enum</td><td style="text-align:center">explicit</td></tr><tr><td style="text-align:center">export</td><td style="text-align:center">extern</td><td style="text-align:center">false</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">for</td><td style="text-align:center">friend</td><td style="text-align:center">goto</td><td style="text-align:center">if</td></tr><tr><td style="text-align:center">inline</td><td style="text-align:center">int</td><td style="text-align:center">long</td><td style="text-align:center">mutable</td></tr><tr><td style="text-align:center">namespace</td><td style="text-align:center">new</td><td style="text-align:center">noexcept</td><td style="text-align:center">not</td></tr><tr><td style="text-align:center">not_eq</td><td style="text-align:center">nullptr</td><td style="text-align:center">operator</td><td style="text-align:center">or</td></tr><tr><td style="text-align:center">or_eq</td><td style="text-align:center">private</td><td style="text-align:center">protected</td><td style="text-align:center">public</td></tr><tr><td style="text-align:center">reflexpr</td><td style="text-align:center">register</td><td style="text-align:center">reinterpret_cast</td><td style="text-align:center">requires</td></tr><tr><td style="text-align:center">return</td><td style="text-align:center">short</td><td style="text-align:center">signed</td><td style="text-align:center">sizeof</td></tr><tr><td style="text-align:center">static</td><td style="text-align:center">static_assert</td><td style="text-align:center">static_cast</td><td style="text-align:center">struct</td></tr><tr><td style="text-align:center">switch</td><td style="text-align:center">synchronized</td><td style="text-align:center">template</td><td style="text-align:center">this</td></tr><tr><td style="text-align:center">thread_local</td><td style="text-align:center">throw</td><td style="text-align:center">true</td><td style="text-align:center">try</td></tr><tr><td style="text-align:center">typedef</td><td style="text-align:center">typeid</td><td style="text-align:center">typename</td><td style="text-align:center">union</td></tr><tr><td style="text-align:center">unsigned</td><td style="text-align:center">using</td><td style="text-align:center">virtual</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">volatile</td><td style="text-align:center">wchar_t</td><td style="text-align:center">while</td><td style="text-align:center">xor</td></tr><tr><td style="text-align:center">xor_eq</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="2、命名空间"><a href="#2、命名空间" class="headerlink" title="2、命名空间"></a>2、命名空间</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>命名空间（<strong><code>namespace</code></strong>）是C++中用于组织和管理代码的一种机制。它提供了一种将全局作用域划分为更小、更可管理的部分的方式。</p><p>在C/C++中，变量、函数和后面要学到的类（结构体）都是大量存在的，其中大部分变量、函数和类的名称将都存在于全局作用域中，这将导致很多命名冲突。使用命名空间的目的是对标识符的名称进行<strong>本地化</strong>， 以避免命名冲突或名字污染，命名空间由此诞生。</p><h3 id="2-2-产生原因"><a href="#2-2-产生原因" class="headerlink" title="2.2 产生原因"></a>2.2 产生原因</h3><p>首先我们先来看为什么会产生命名空间？</p><p>例如在大型项目中需要分工合作，在整合代码时每个人的命名风格或形式或同或不同，虽然说一般企业会对代码有规范要求，但是避免不了会出现同名等情况，来看个c语言例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> rand = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// C语言没办法解决类似这样的命名冲突问题，所以C++提出了namespace来解决</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后后报错：error C2365: “rand”: 重定义；以前的定义是自带的rand“函数”</span></span><br><span class="line"><span class="comment">// 就与你在一个工程代码中无法定义两个同名的标识符是一个原理</span></span><br></pre></td></tr></table></figure><h3 id="2-3-解决方案"><a href="#2-3-解决方案" class="headerlink" title="2.3 解决方案"></a>2.3 解决方案</h3><p>针对上述问题，命名空间<code>namespace</code>应运而生。</p><p>先提及一下大家在大部分C++语言书上所看到的示例<code>using namespace std</code>，大部分书籍上会解释是为了编写方便，导致很多读者认为这是C+程序的固定样式，然而并非如此，需要摒弃此观念！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-1-笔者对命名空间的理解"><a href="#2-3-1-笔者对命名空间的理解" class="headerlink" title="2.3.1 笔者对命名空间的理解"></a><strong>2.3.1</strong> 笔者对命名空间的理解</h4><p>以将命名空间<code>namespace</code>看作私人领域的围墙，每个人都可以在自己的领域做任何事情，但是别人不能擅闯你的区域，除非获得你的许可。</p><h4 id="2-3-2-在项目工程中的理解"><a href="#2-3-2-在项目工程中的理解" class="headerlink" title="2.3.2 在项目工程中的理解"></a><strong>2.3.2 在项目工程中的理解</strong></h4><p>在编程人员单人开发时，使用命名空间可以将不同模块的代码区分开避免冲突，并提供更好的代码隔离性。</p><p>多人开发时，同样可以避免项目整合是发生的命名冲突等问题。</p><h4 id="2-3-3-使用方式"><a href="#2-3-3-使用方式" class="headerlink" title="2.3.3 使用方式"></a><strong>2.3.3 使用方式</strong></h4><p><strong>如何获取许可证呢？</strong></p><p>正如上面示例的<code>HelloWorld</code>代码，使用<code>using namespace std</code>即可。</p><p><strong>这行代码该如何解释呢？</strong></p><h5 id="using-namespace-std"><a href="#using-namespace-std" class="headerlink" title="using namespace std"></a><code>using namespace std</code></h5><p><code>std</code>是C++标准库的命名空间，其中包含了许多常用的类、函数和对象，如输入输出、字符串处理、容器、算法等等。</p><p>在没有使用<code>using namespace std;</code>的情况下，访问标准库中的成员需要在其名称前加上<code>std::</code>前缀，例如<code>std::cout</code>。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>using</code>就相当于许可证，使用<code>using</code>就可以获取围墙内的信息，并且随意使用内部内容。</p><p>正如笔者之前提的建议，尽量不要直接使用<code>using namespace std</code>，利弊参半。<strong>谨慎使用</strong>！！！</p><p>原因如下：</p><p>使用<code>using namespace std</code>可以简化代码，使得在使用标准库成员时不需要写出完整的命名空间前缀，而可以直接使用它们。</p><p>例如，在使用了<code>using namespace std</code>后，可以直接使用<code>cout</code>、<code>string</code>而不需要加上<code>std::</code>前缀。</p><p>需要注意的是，<code>using namespace std</code>将整个<code>std</code>命名空间引入当前的作用域中。</p><p>这样可以减少代码中的冗余，但也可能引入命名冲突的风险。在大型项目中或需要与其他命名空间中的成员进行区分的情况下，可以避免使用<code>using namespace std</code>，而是使用具体的<code>using</code>声明来引入需要的特定成员。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="作用域解析符"><a href="#作用域解析符" class="headerlink" title="作用域解析符"></a><code>作用域解析符</code></h5><p>在C++中，作用域解析运算符（Scope Resolution Operator），用双冒号（::）表示，用于访问命名空间、类、结构体、枚举等的成员。</p><p>这也是通行证的一种，不过每次使用内部内容时，都需要加上该符号去获取，需要什么便可以取什么。</p><p>相对于使用<code>using namespace + 命名空间</code>全部展开，此法与<code>using 命名空间::需要内容</code>相似，减小冲突风险。</p><h3 id="2-4-使用示例"><a href="#2-4-使用示例" class="headerlink" title="2.4 使用示例"></a>2.4 使用示例</h3><p>解决上述提到的c语言的冲突问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kaite&#123;</span><br><span class="line"><span class="type">int</span> rand = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; kaite::rand &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用<code>using namespace std</code>是为了展示冲突，建议读者使用另外两种方式编写。</p><p>上述代码定义了命名空间<code>kaite</code>，即使我将命名空间<code>std</code>全部展开，其中有<code>rand</code>函数，但是我并没有展开自己的命名空间，而是使用作用域解析符跨围墙寻找，因此不会和全局冲突。</p><p>相信解释到这里，读者应该已经对命名空间有一定的了解。下面列出一些注意事项。</p><h3 id="2-5-注意事项"><a href="#2-5-注意事项" class="headerlink" title="2.5 注意事项"></a>2.5 注意事项</h3><p><strong>命名空间可以嵌套定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N1</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">namespace</span> N2</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> c;</span><br><span class="line">     <span class="type">int</span> d;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想使用命名空间N2中的变量也需要嵌套寻求</span></span><br><span class="line">N1::N2::c = <span class="number">0</span>;</span><br><span class="line">N1::N2::d = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p> <strong>同项目中的同名命名空间会进行合并</strong></p><p>同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中。</p><p>一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。</p><h2 id="3、-C-输入-amp-输出"><a href="#3、-C-输入-amp-输出" class="headerlink" title="3、  C++输入&amp;输出"></a>3、  C++输入&amp;输出</h2><p>本节要介绍的是在之前的程序中已经见识过的<code>cout</code>与<code>cin</code>。</p><p>在C++中，<code>cout</code>和<code>cin</code>是两个重要的标准库对象，分别用于输出和输入数据。</p><p>它们是<code>ostream</code>和<code>istream</code>类的实例，通过使用流插入运算符 <code>&lt;&lt;</code>（插入到流中）和流提取运算符 <code>&gt;&gt;</code>（从流中提取）来进行数据的输入和输出。</p><h4 id="3-1-输入流和输出流类"><a href="#3-1-输入流和输出流类" class="headerlink" title="3.1 输入流和输出流类"></a>3.1 输入流和输出流类</h4><ol><li><code>istream</code>（输入流）：用于从输入源（如键盘、文件）读取数据。</li><li><code>ostream</code>（输出流）：用于向输出目标（如终端、文件）写入数据。</li></ol><h5 id="3-1-1-cout"><a href="#3-1-1-cout" class="headerlink" title="3.1.1 cout"></a>3.1.1 <code>cout</code></h5><p><code>cout</code>（Character Output）是标准输出流对象，用于向终端或其他输出目标打印数据。</p><p>可以使用<code>&lt;&lt;</code>运算符将数据插入到<code>cout</code>流中，然后将其输出到终端。以下是一个简单的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    std::string message = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数：&quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串：&quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用<code>cout</code>对象将整数和字符串输出到终端。可以使用<code>&lt;&lt;</code>运算符依次插入要输出的数据。<code>endl</code>是一个特殊的操作符，用于插入换行符并刷新输出流。</p><h5 id="3-1-2-cin"><a href="#3-1-2-cin" class="headerlink" title="3.1.2  cin"></a>3.1.2  <code>cin</code></h5><p><code>cin</code>（Character Input）是标准输入流对象，用于从键盘或其他输入源获取数据。</p><p>可以使用<code>&gt;&gt;</code>运算符从<code>cin</code>流中提取数据，然后将其存储到相应的变量中。以下是一个简单的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入您的年龄：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; age;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;您的年龄是：&quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用<code>cin</code>对象从用户输入读取整数，并将其存储在变量<code>age</code>中。可以使用<code>&gt;&gt;</code>运算符将输入流中的数据提取到变量中</p><h4 id="3-2-说明"><a href="#3-2-说明" class="headerlink" title="3.2 说明"></a>3.2 说明</h4><ol><li>使用<code>cout</code>标准输出对象(控制台)和<code>cin</code>标准输入对象(键盘)时，必须包含<code>&lt; iostream &gt;</code>头文件 以及按命名空间使用方法使用std。</li><li><code>cout</code>和<code>cin</code>是全局的流对象，<code>endl</code>是特殊的C++符号，表示换行输出，他们都包含在包含<code>&lt; iostream &gt;</code>头文件中。</li><li>使用C++输入输出更方便，不需要像<code>printf/scanf</code>输入输出时那样，需要手动控制格式。 C++的输入输出可以自动识别变量类型。</li><li>. &lt;&lt;是流插入运算符，&gt;&gt;是流提取运算符。</li><li><code>cout</code>和<code>cin</code>分别是<code>ostream</code>和<code>istream</code>类型的对象，本文有提及，但是关于类的知识后续文章再进行介绍。&gt;&gt;和&lt;&lt;也涉及运算符重载等知识，这里只是简单学习他们的使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『C语言入门』分支和循环语句</title>
      <link href="/2023/09/18/%E3%80%8EC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E3%80%8F%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/09/18/%E3%80%8EC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E3%80%8F%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>在编程中，我们需要让程序<strong>根据不同情况作出选择，并重复执行某些任务</strong>。C语言的分支和循环结构为实现这些目标提供了强大的工具。本文将探索C语言中的分支（如<code>if</code>和<code>switch</code>）以及循环（如<code>while</code>、<code>for</code>和<code>do...while</code>）结构，帮助你理解如何更有效地控制程序的流程和逻辑。无论你是初学者还是有经验的开发者，这些知识都将为你的编程旅程增添价值。</p></blockquote><h1 id="一、什么是语句？"><a href="#一、什么是语句？" class="headerlink" title="一、什么是语句？"></a>一、什么是语句？</h1><blockquote><p>在编程中，语句是构成程序的基本元素之一，它们<strong>代表了计算机需要执行的指令或操作</strong>。语句是程序中的操作单位，通过组合不同类型的语句，我们可以构建出复杂的程序逻辑和功能。在C语言中，语句可以分为多种类型，包括<strong>表达式语句</strong>、<strong>赋值语句</strong>、<strong>条件语句</strong>等，每种类型都有其特定的作用和用法。</p></blockquote><p><strong>让我们来看一些常见的C语言语句示例，以便更好地理解语句的概念：</strong></p><h2 id="1-1表达式语句"><a href="#1-1表达式语句" class="headerlink" title="1.1表达式语句"></a>1.1表达式语句</h2><blockquote><p>表达式是由运算符、操作数和函数调用组成的计算式，表达式语句通常用于执行一些计算操作，但它的结果通常不会被使用。</p></blockquote><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y + z;    <span class="comment">// 赋值表达式</span></span><br><span class="line">result = a * b + c;    <span class="comment">// 数学表达式</span></span><br></pre></td></tr></table></figure><h2 id="1-2赋值语句"><a href="#1-2赋值语句" class="headerlink" title="1.2赋值语句"></a>1.2赋值语句</h2><blockquote><p>赋值语句用于将一个值赋给变量，从而更新变量的内容。这在程序中经常用于存储数据和计算结果。</p></blockquote><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span>;    <span class="comment">// 将值10赋给变量num</span></span><br><span class="line">total = total + price;    <span class="comment">// 将total和price的和赋给total</span></span><br></pre></td></tr></table></figure><h2 id="1-3函数调用语句"><a href="#1-3函数调用语句" class="headerlink" title="1.3函数调用语句"></a>1.3函数调用语句</h2><blockquote><p>函数是一段预定义的代码块，通过函数调用语句，我们可以执行函数内的操作。函数调用语句通常用于完成特定的任务，例如输入输出、数学计算等。</p></blockquote><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!&quot;</span>);    <span class="comment">// 调用printf函数输出文本</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;value);    <span class="comment">// 调用scanf函数读取用户输入的整数</span></span><br></pre></td></tr></table></figure><h2 id="1-4复合语句"><a href="#1-4复合语句" class="headerlink" title="1.4复合语句"></a>1.4复合语句</h2><blockquote><p>复合语句是一组由花括号（<code>&#123;&#125;</code>）括起来的语句，它们被视为一个单元。复合语句可以包含多种类型的语句，用于组织和控制代码的执行。</p></blockquote><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of x is %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5空语句"><a href="#1-5空语句" class="headerlink" title="1.5空语句"></a>1.5空语句</h2><blockquote><p>空语句是指不包含任何操作的语句，它通常用于语法要求需要一条语句但不需要实际操作的情况。空语句只包含一个分号。</p></blockquote><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;    <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure><h2 id="1-6控制语句"><a href="#1-6控制语句" class="headerlink" title="1.6控制语句"></a>1.6控制语句</h2><blockquote><p>控制语句是编程中的关键工具，用于管理程序的执行流程和实现不同的程序结构。在C语言中，控制语句分为三类：</p></blockquote><ol><li><strong>条件判断语句（分支语句）</strong>：这类语句允许根据不同的条件选择不同的执行路径。其中包括：<ul><li><strong>if语句</strong>：根据条件执行代码块，可以包含一个<code>else</code>块，用于处理条件不满足的情况。</li><li><strong>switch语句</strong>：基于表达式的值跳转到不同的<code>case</code>分支，可以实现多条件的选择。</li></ul></li><li><strong>循环执行语句</strong>：这类语句允许反复执行一段代码，直到满足特定条件为止。包括：<ul><li><strong>do while语句</strong>：先执行一次代码块，然后根据条件反复执行。</li><li><strong>while语句</strong>：在循环开始之前判断条件是否满足，满足则执行循环体内代码。</li><li><strong>for语句</strong>：在循环开始之前初始化计数器，根据条件和更新规则反复执行代码块。</li></ul></li><li><strong>转向语句</strong>：这类语句用于控制程序的跳转。包括：<ul><li><strong>break语句</strong>：在循环或switch语句中提前终止循环或跳出switch。</li><li><strong>continue语句</strong>：跳过当前循环迭代的剩余部分，进入下一次迭代。</li><li><strong>return语句</strong>：从函数中返回值，并终止函数的执行。</li><li><strong>goto语句</strong>：尽管不推荐使用，但可以无条件地跳转到代码中的标签位置。</li></ul></li></ol><blockquote><p><strong>本文主要介绍控制语句。</strong></p><p>每个语句都以分号（<code>;</code>）结尾，表示语句的结束。在编写程序时，正确使用分号是非常重要的，因为<strong>它们告诉编译器何时一个语句结束，何时开始下一个语句。</strong></p></blockquote><h1 id="二、分支语句"><a href="#二、分支语句" class="headerlink" title="二、分支语句"></a>二、分支语句</h1><blockquote><p>分支语句是C语言中的重要控制结构之一，它允许程序根据不同的条件选择不同的执行路径。通过分支语句，你可以<strong>实现有条件的程序执行，从而使程序更具智能和灵活性</strong>。C语言中的分支语句主要包括<code>if</code>语句和<code>switch</code>语句。</p></blockquote><h2 id="2-1-if语句"><a href="#2-1-if语句" class="headerlink" title="2.1 if语句"></a>2.1 <code>if</code>语句</h2><blockquote><p>在C语言中，<code>if</code>语句是一种重要的<strong>条件判断语句</strong>，它允许根据条件的<strong>真假</strong>执行不同的代码块，从而实现有条件的程序执行。<code>if</code>语句的灵活性使得我们可以根据不同的情况选择不同的程序路径，使程序更加智能和逻辑清晰。</p></blockquote><h3 id="2-1-1基本语法"><a href="#2-1-1基本语法" class="headerlink" title="2.1.1基本语法"></a>2.1.1基本语法</h3><p><code>if</code>语句的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 如果条件为真，执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>条件</code>是一个布尔表达式或可求值为布尔值的表达式。如果条件的值为真（非零），则执行花括号内的代码块；如果条件的值为假（零），则跳过这个代码块，继续执行后续的代码。</li></ul><p>下面是一个简单的例子，演示了如何使用<code>if</code>语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is positive.\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program finished.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，用户被要求输入一个整数。程序使用<code>if</code>语句检查输入的整数是否为正数。如果是正数（即条件<code>num &gt; 0</code>为真），则输出相应的信息；否则，直接跳过输出部分，继续执行后续代码。</p><h3 id="2-1-2使用else语句"><a href="#2-1-2使用else语句" class="headerlink" title="2.1.2使用else语句"></a>2.1.2使用<code>else</code>语句</h3><blockquote><p>除了基本的<code>if</code>语句外，你还可以使用<code>else</code>来指定在条件不满足时执行另一段代码块：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is positive.\n&quot;</span>, num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is not positive.\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program finished.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，根据用户输入的整数，程序会输出相应的信息，要么是正数，要么是不是正数。<code>else</code>语句使你能够在两个不同的可能性之间做出选择。</p><h3 id="2-1-3嵌套if语句"><a href="#2-1-3嵌套if语句" class="headerlink" title="2.1.3嵌套if语句"></a>2.1.3嵌套if语句</h3><blockquote><p>你还可以在一个<code>if</code>语句内嵌套另一个<code>if</code>语句，以处理更复杂的条件情况：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter an integer: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is positive.\n&quot;</span>, num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is negative.\n&quot;</span>, num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is zero.\n&quot;</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program finished.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，根据用户输入的整数，程序会输出<strong>正数、负数或零</strong>的信息。这利用了嵌套的<code>if</code>语句来处理不同的情况。</p><h3 id="2-1-4多层if-else语句"><a href="#2-1-4多层if-else语句" class="headerlink" title="2.1.4多层if-else语句"></a>2.1.4多层<code>if-else</code>语句</h3><blockquote><p>在实际编程中，经常会遇到需要同时判断<strong>多个条件</strong>的情况。为了处理这样的复杂情况，你可以使用<strong>多层</strong>的<code>if-else</code>语句来实现不同条件下的不同操作。多层<code>if-else</code>语句能够有效地组合和嵌套条件判断，以处理多重条件。</p></blockquote><p>多层<code>if-else</code>语句的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 条件1为真时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 条件2为真时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 条件3为真时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 所有条件均不满足时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这种结构允许你根据多个条件逐个判断，直到找到第一个满足条件的分支，然后执行相应的代码块。</strong>如果所有条件都不满足，最后的<code>else</code>代码块将会执行。</p><p>以下示例展示了多层<code>if-else</code>语句的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your score: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Grade: A\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Grade: B\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Grade: C\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Grade: D\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Grade: F\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，根据用户输入的分数，程序使用多层<code>if-else</code>语句来判断其所在的分数段，并输出相应的等级。根据分数的不同，程序会在不同的条件分支中选择执行。</p><blockquote><p>多层<code>if-else</code>语句能够清晰地表达多重条件判断的逻辑，使得程序结构更加直观和易于理解。当你需要处理多个条件时，将多个<code>if-else</code>分支组合在一起，可以有效地构建复杂的程序逻辑。</p><p><code>if</code>语句是实现有条件的程序执行的重要工具。无论是输入验证还是多重条件判断，合理地使用不同形式的<code>if</code>语句，都可以使程序的逻辑更加清晰和智能。</p></blockquote><h2 id="2-2-switch语句"><a href="#2-2-switch语句" class="headerlink" title="2.2 switch语句"></a>2.2 <code>switch</code>语句</h2><blockquote><p>在C语言中，<code>switch</code>语句是一种用于多重条件选择的控制语句。它允许根据表达式的值在多个<code>case</code>分支中选择执行不同的代码块。<code>switch</code>语句可以使程序更加简洁和易于理解，特别是当需要处理多个固定值时。</p></blockquote><h3 id="2-2-1基本语法"><a href="#2-2-1基本语法" class="headerlink" title="2.2.1基本语法"></a>2.2.1基本语法</h3><p><code>switch</code>语句的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 当表达式的值等于值1时，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 当表达式的值等于值2时，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 更多case...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果表达式的值不匹配任何case时，执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>表达式</code>是一个可求值的表达式，其值将与每个<code>case</code>标签进行比较。</li><li>每个<code>case</code>标签后跟着一个需要匹配的值和一个冒号。</li><li>如果<code>表达式</code>的值与某个<code>case</code>标签匹配，则会执行该<code>case</code>标签下的代码块。在执行完代码块后，可以通过使用<code>break</code>语句跳出<code>switch</code>语句，以防止进一步执行其他<code>case</code>块。如果没有<code>break</code>语句，程序将会继续执行下一个<code>case</code>。</li></ul><h3 id="2-2-2示例"><a href="#2-2-2示例" class="headerlink" title="2.2.2示例"></a>2.2.2示例</h3><p>考虑以下示例，演示了如何使用<code>switch</code>语句处理不同运算符对应的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> operator;</span><br><span class="line">    <span class="type">double</span> num1, num2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter an operator (+, -, *, /): &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;operator);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter two numbers: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf + %.2lf = %.2lf\n&quot;</span>, num1, num2, num1 + num2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf - %.2lf = %.2lf\n&quot;</span>, num1, num2, num1 - num2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf * %.2lf = %.2lf\n&quot;</span>, num1, num2, num1 * num2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%.2lf / %.2lf = %.2lf\n&quot;</span>, num1, num2, num1 / num2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: Division by zero.\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid operator.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，用户首先被要求输入一个运算符，然后输入两个数字。程序使用<code>switch</code>语句根据运算符选择执行不同的计算，并输出结果。根据运算符的不同，程序会选择执行相应的<code>case</code>分支。</p><blockquote><p><code>switch</code>语句适用于当你需要根据多个固定选项来决定执行哪一段代码时。使用<code>switch</code>语句可以使代码结构更加整洁和易于维护。不过需要注意，在每个<code>case</code>分支中使用<code>break</code>语句来避免不必要的<strong>穿透</strong>。</p></blockquote><h3 id="2-2-3穿透"><a href="#2-2-3穿透" class="headerlink" title="2.2.3穿透"></a>2.2.3穿透</h3><blockquote><p>在C语言的<code>switch</code>语句中，如果在一个<code>case</code>分支中没有使用<code>break</code>语句，那么程序将会“穿透”到下一个<code>case</code>分支中继续执行，而不会跳过后续的<code>case</code>。这种现象被称为“穿透”或“fall-through”。</p></blockquote><p>考虑以下示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a number between 1 and 3: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (choice) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You chose 1.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You chose 2.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;You chose 3.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid choice.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果用户输入的数字是1，程序会输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">You chose <span class="number">1.</span></span><br><span class="line">You chose <span class="number">2.</span></span><br><span class="line">You chose <span class="number">3.</span></span><br><span class="line">Invalid choice.</span><br></pre></td></tr></table></figure><p>这是因为在<code>case 1</code>的代码块中没有使用<code>break</code>语句，所以程序继续执行下一个<code>case</code>，以及后续的所有代码块，直到<code>switch</code>语句结束或遇到<code>break</code>为止。这就导致了穿透现象。</p><blockquote><p><strong>为了避免意外的穿透</strong>，通常在每个<code>case</code>分支的代码块末尾使用<code>break</code>语句。如果希望每个分支都执行独立的逻辑且不会穿透到其他分支，<code>break</code>语句是必要的。如果需要有意的穿透，可以有选择地省略<code>break</code>，但在这种情况下，需要特别小心以确保代码的预期行为。</p></blockquote><h1 id="三、循环语句"><a href="#三、循环语句" class="headerlink" title="三、循环语句"></a>三、循环语句</h1><blockquote><p>在学习编程的旅程中，掌握循环语句是至关重要的一步。C语言作为一门广泛应用的编程语言，提供了多种循环语句，用于处理重复性任务。本章节将帮助您逐步了解<code>for</code>、<code>while</code>和<code>do-while</code>三种循环，为您的学习之路提供详细的指导。</p></blockquote><h2 id="3-1for循环"><a href="#3-1for循环" class="headerlink" title="3.1for循环"></a>3.1<code>for</code>循环</h2><p><code>for</code>循环通常用于在已知的次数范围内重复执行代码。它由三个关键部分组成：</p><ul><li>初始化：在循环开始前执行的语句，通常用于初始化计数器。</li><li>条件：在每次循环迭代前检查的条件，如果条件为真，循环将继续执行。</li><li>更新：在每次循环迭代后执行的语句，通常用于递增或递减计数器。</li></ul><p><strong>示例：</strong> 让我们使用<code>for</code>循环输出前10个自然数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1break和continue"><a href="#3-1-1break和continue" class="headerlink" title="3.1.1break和continue"></a>3.1.1<code>break</code>和<code>continue</code></h3><blockquote><p>当在C语言的<code>for</code>循环中使用<code>break</code>和<code>continue</code>语句时，它们分别用于控制循环的中断和跳过。</p></blockquote><p><strong><code>break</code>语句</strong> </p><blockquote><p><code>break</code>语句用于在循环内部中断循环的执行，无论循环条件是否满足。一旦<code>break</code>语句执行，循环将立即终止，程序将继续执行循环之后的代码。</p></blockquote><p><strong>示例：</strong> 使用<code>break</code>语句在<code>for</code>循环中找到第一个满足条件的数字并终止循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到满足条件的数字：%d\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 循环中断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>continue</code>语句</strong></p><blockquote><p><code>continue</code>语句用于跳过当前循环迭代的剩余部分，并继续下一次迭代。它将不执行当前迭代中<code>continue</code>语句后面的代码，而是直接进入下一次循环迭代。</p></blockquote><p><strong>示例：</strong> 使用<code>continue</code>语句跳过某些特定数字的输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 跳过偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用这些语句时，要注意它们的影响范围。<code>break</code>会立即中断循环，并退出循环体，而<code>continue</code>只是跳过当前迭代的剩余部分，然后继续下一次迭代。使用这些语句可以更灵活地控制循环的行为，使代码逻辑更加清晰和可读。</p><blockquote><p>总之，<code>break</code>用于完全中断循环，而<code>continue</code>用于跳过当前迭代。这两个关键字在不同情况下能够帮助您更好地处理循环中的逻辑。</p></blockquote><h3 id="3-1-2循环控制变量"><a href="#3-1-2循环控制变量" class="headerlink" title="3.1.2循环控制变量"></a>3.1.2循环控制变量</h3><p><strong>1. 不可在<code>for</code>循环体内修改循环变量，防止循环失去控制：</strong></p><blockquote><p>循环控制变量在<code>for</code>循环的初始化部分被定义，并在每次迭代后在更新部分进行更新。在循环体内修改循环控制变量可能会导致循环条件不再满足，从而导致循环行为出现问题，甚至导致无限循环。</p></blockquote><p><strong>示例：</strong> 错误的修改循环控制变量示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        i--;  <span class="comment">// 错误：在循环体内修改循环控制变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 建议<code>for</code>语句的循环控制变量的取值采用“前闭后开区间”写法：</strong></p><blockquote><p>使用“前闭后开区间”写法可以避免循环条件边界值的问题，同时也使得循环的行为更加清晰和容易理解。</p></blockquote><p><strong>示例：</strong> 使用“前闭后开区间”写法的<code>for</code>循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 从1到10（包括1，不包括10）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法中，循环变量<code>i</code>的值从1开始，在条件部分使用<code>&lt;</code>号，确保循环不会执行到10。</p><p><strong>3. 合理选择循环控制变量的命名：</strong></p><blockquote><p>循环控制变量的命名应该具有描述性，可以使代码更具可读性。通常，使用简洁而有意义的变量名能够使代码更清晰地传达循环的意图。</p></blockquote><p><strong>示例：</strong> 使用描述性变量名的<code>for</code>循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num_of_students = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> student_id = <span class="number">1</span>; student_id &lt;= num_of_students; student_id++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;处理学生 %d\n&quot;</span>, student_id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，循环控制变量<code>student_id</code>能够清楚地表示正在处理的学生编号。</p><h3 id="3-1-3循环变种"><a href="#3-1-3循环变种" class="headerlink" title="3.1.3循环变种"></a>3.1.3循环变种</h3><blockquote><p>C语言的<code>for</code>循环可以有多种变种，可以根据不同的需求和场景来适应不同的情况。</p></blockquote><p>以下是一些常见的<code>for</code>循环变种示例：</p><p><strong>1. 倒序循环：</strong></p><blockquote><p>通常，<code>for</code>循环是从一个初始值递增到一个结束值，但您也可以将其用于倒序循环。这可以通过递减循环控制变量来实现。</p></blockquote><p><strong>示例：</strong> 使用<code>for</code>循环倒序输出10到1的数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.无限循环：</strong></p><blockquote><p>有时候需要创建一个无限循环，可以在循环条件部分使用<code>true</code>或非零值来实现。</p></blockquote><p><strong>示例：</strong> 使用<code>for</code>循环创建无限循环，需要手动中断循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;这是一个无限循环\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加适当的中断条件，如按下Ctrl+C</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.多变量循环：</strong></p><blockquote><p><code>for</code>循环可以在初始化部分同时初始化多个循环控制变量，并在更新部分对它们进行更新。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d\n&quot;</span>, i, j, i * j);</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这些是<code>for</code>循环的一些常见变种，但还有更多的变种方式，可以根据实际需求进行适当调整。<code>for</code>循环是非常灵活的，可以用于各种不同的循环场景。根据不同的情况，选择适当的循环变种能够使您的代码更加简洁、高效和可读。</p></blockquote><h2 id="3-2while循环"><a href="#3-2while循环" class="headerlink" title="3.2while循环"></a>3.2<code>while</code>循环</h2><blockquote><p>在C语言中，<code>while</code>循环是一种强大的循环结构，它允许您在条件为真的情况下重复执行一段代码。相比于<code>for</code>循环，<code>while</code>循环更加灵活，适用于需要根据条件来动态控制循环次数的场景。让我们深入了解<code>while</code>循环的语法、工作原理以及一些常见的用法。</p></blockquote><h3 id="3-2-1语法"><a href="#3-2-1语法" class="headerlink" title="3.2.1语法"></a>3.2.1语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2工作原理"><a href="#3-2-2工作原理" class="headerlink" title="3.2.2工作原理"></a>3.2.2工作原理</h3><blockquote><p><code>while</code>循环会在每次循环开始之前，先判断条件是否为真。只要条件为真，循环体就会被执行。当循环体执行完毕后，会再次检查条件，然后决定是否继续下一次循环。如果条件为假，循环会终止，程序将继续执行循环之后的代码。</p></blockquote><p><strong>示例：</strong> 使用<code>while</code>循环计算用户输入数字的平方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number, square;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">        square = number * number;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数字 %d 的平方是 %d\n&quot;</span>, number, square);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环结束，感谢使用！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3常见用法"><a href="#3-2-3常见用法" class="headerlink" title="3.2.3常见用法"></a>3.2.3常见用法</h3><blockquote><ol><li><strong>处理用户输入：</strong> 使用<code>while</code>循环可以反复获取用户输入，直到满足特定条件。</li><li><strong>处理文件内容：</strong> 可以使用<code>while</code>循环逐行读取文件内容，直到文件结束。</li><li><strong>动态计算：</strong> 当循环次数无法提前确定时，可以使用<code>while</code>循环根据条件来动态计算循环次数。</li><li><strong>无限循环：</strong> 可以使用<code>while (1)</code>来创建无限循环，然后在适当条件下中断循环。</li><li><strong>游戏循环：</strong> 游戏开发中常用的游戏循环就是基于<code>while</code>循环的。</li></ol><p><code>while</code>循环的灵活性使它在许多编程场景中非常有用。不过，与其他循环一样，要小心避免造成无限循环，确保循环条件能够在某个时刻为假，从而终止循环。</p></blockquote><h3 id="3-2-4break语句与continue"><a href="#3-2-4break语句与continue" class="headerlink" title="3.2.4break语句与continue"></a>3.2.4<code>break</code>语句与<code>continue</code></h3><blockquote><p>在<code>while</code>循环中，同样可以使用<code>break</code>和<code>continue</code>语句来控制循环的流程。这些关键字在<code>while</code>循环中的作用与在其他循环类型中是类似的。</p></blockquote><ol><li><p><strong>break语句：</strong> </p><blockquote><p><code>break</code>语句用于在<code>while</code>循环内部立即终止循环的执行，无论循环条件是否为真。当<code>break</code>语句被执行时，循环会立即结束，程序将继续执行循环之后的代码。</p></blockquote><p><strong>示例：</strong> 使用<code>while</code>循环找到第一个满足条件的数字并终止循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (number &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到满足条件的数字：%d\n&quot;</span>, number);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 循环中断</span></span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>continue语句：</strong> </p><blockquote><p><code>continue</code>语句用于跳过当前循环迭代的剩余部分，直接进入下一次循环迭代。它会终止当前迭代的循环体部分，然后检查循环条件，决定是否继续下一次迭代。</p></blockquote><p><strong>示例：</strong> 使用<code>while</code>循环输出奇数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 跳过偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>break</code>和<code>continue</code>语句在<code>while</code>循环中的作用与在其他循环中的作用相同。它们可以在循环内部实现条件跳出和跳过的需求，帮助您更精确地控制循环的执行流程。但请确保在使用它们时，不会导致无限循环或跳过循环的重要部分。</p></blockquote><h2 id="3-3do-while循环"><a href="#3-3do-while循环" class="headerlink" title="3.3do-while循环"></a>3.3<code>do-while</code>循环</h2><blockquote><p><code>do-while</code>循环是C语言中的一种循环结构，它与<code>while</code>循环有些类似，但有一个重要区别：<code>do-while</code>循环会先执行一次循环体，然后在每次迭代结束后检查循环条件是否满足。让我们深入了解<code>do-while</code>循环的语法、工作原理以及一些常见的应用场景。</p></blockquote><h3 id="3-3-1语法"><a href="#3-3-1语法" class="headerlink" title="3.3.1语法"></a>3.3.1语法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure><h3 id="3-3-2工作原理"><a href="#3-3-2工作原理" class="headerlink" title="3.3.2工作原理"></a>3.3.2工作原理</h3><blockquote><p><code>do-while</code>循环会首先执行一次循环体中的代码，然后检查循环条件是否为真。只要条件为真，循环会继续迭代，继续执行循环体，然后再次检查循环条件。如果条件为假，循环将终止，程序将继续执行循环之后的代码。</p></blockquote><p><strong>示例：</strong> 使用<code>do-while</code>循环获取用户输入，直到输入合法为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个正整数：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">    &#125; <span class="keyword">while</span> (number &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的是：%d\n&quot;</span>, number);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3常见用法"><a href="#3-3-3常见用法" class="headerlink" title="3.3.3常见用法"></a>3.3.3常见用法</h3><blockquote><ol><li><strong>用户输入验证：</strong> 使用<code>do-while</code>循环可以确保用户至少输入一次，并在每次迭代中验证输入的有效性。</li><li><strong>菜单选择：</strong> 在菜单选择等场景中，<code>do-while</code>循环可用于持续显示选项并等待用户选择，直到用户选择退出。</li><li><strong>处理用户反馈：</strong> 可以使用<code>do-while</code>循环获取用户反馈，然后根据反馈决定是否继续执行。</li><li><strong>模拟游戏轮次：</strong> 游戏中的回合制操作可以使用<code>do-while</code>循环来实现。</li></ol><p><code>do-while</code>循环确保循环体至少会被执行一次，适用于需要在循环前执行一些操作的情况。要注意，循环条件必须在循环体的结尾处，这确保了至少执行一次循环体。</p></blockquote><h3 id="3-3-4break语句与continue"><a href="#3-3-4break语句与continue" class="headerlink" title="3.3.4break语句与continue"></a>3.3.4<code>break</code>语句与<code>continue</code></h3><ol><li><p><strong>break语句</strong></p><blockquote><p> <code>break</code>语句用于在<code>do-while</code>循环内部立即终止循环的执行，无论循环条件是否为真。当<code>break</code>语句被执行时，循环会立即结束，程序将继续执行循环之后的代码。</p></blockquote><p><strong>示例：</strong> 使用<code>do-while</code>循环找到第一个满足条件的数字并终止循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到满足条件的数字：%d\n&quot;</span>, number);</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 循环中断</span></span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (number &lt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>continue语句</strong> </p><blockquote><p><code>continue</code>语句用于跳过当前循环迭代的剩余部分，直接进入下一次循环迭代。它会终止当前迭代的循环体部分，然后重新开始新的迭代。</p></blockquote><p><strong>示例：</strong> 使用<code>do-while</code>循环输出奇数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 跳过偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><code>break</code>和<code>continue</code>语句在<code>do-while</code>循环中的作用与在其他循环中的作用相同。它们都可以用于在循环内部实现条件跳出和跳过的需求，帮助您更灵活地控制循环的执行流程。确保在使用它们时，不会导致无限循环或跳过循环的重要部分。</p></blockquote><h2 id="3-4goto语句"><a href="#3-4goto语句" class="headerlink" title="3.4goto语句"></a>3.4<code>goto</code>语句</h2><blockquote><p><code>goto</code>语句是C语言中的一种跳转语句，它允许直接跳转到程序中的另一个标签（或标识符）位置。然而，值得注意的是，使用<code>goto</code>语句可能会导致代码变得难以理解和维护，因此在编程中应谨慎使用。</p></blockquote><h3 id="3-4-1基本语法"><a href="#3-4-1基本语法" class="headerlink" title="3.4.1基本语法"></a>3.4.1基本语法</h3><p>在C语言中，<code>goto</code>语句的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">label:</span><br><span class="line"><span class="comment">// 代码段</span></span><br></pre></td></tr></table></figure><p>上述代码会将程序的控制流从<code>goto</code>语句跳转到标签<code>label</code>所在的位置</p><h3 id="3-4-2示例"><a href="#3-4-2示例" class="headerlink" title="3.4.2示例"></a>3.4.2示例</h3><blockquote><p>当涉及到<code>goto</code>语句的使用示例时，我们可以考虑一个简单的错误处理场景。假设我们正在编写一个函数，该函数从文件中读取数据，如果读取失败，则需要进行错误处理。</p></blockquote><p>以下是一个使用<code>goto</code>语句的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open the file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件中的数据</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="comment">// 错误处理逻辑</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;An error occurred.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，如果文件无法打开，程序将跳转到标签<code>error</code>处进行错误处理。这种情况下，<code>goto</code>语句可以帮助我们在错误发生时避免重复编写错误处理逻辑。</p><h3 id="3-4-3优点"><a href="#3-4-3优点" class="headerlink" title="3.4.3优点"></a>3.4.3优点</h3><p>尽管<code>goto</code>语句在现代编程实践中受到质疑，但它在某些特定情况下仍然可以提供帮助：</p><blockquote><ol><li><strong>错误处理：</strong> 在处理错误时，<code>goto</code>语句可以让您跳转到一个共享的错误处理代码块，以避免在每个错误检查点都重复编写相同的错误处理逻辑。</li><li><strong>复杂的跳转逻辑：</strong> 有时，一些算法或逻辑可能需要复杂的跳转路径，而<code>goto</code>可以使这些逻辑更清晰地表达。</li></ol></blockquote><h3 id="3-4-4缺点"><a href="#3-4-4缺点" class="headerlink" title="3.4.4缺点"></a>3.4.4缺点</h3><p>然而，<code>goto</code>语句的使用也带来了一些严重的问题：</p><blockquote><ol><li><strong>可读性差：</strong> 使用<code>goto</code>语句可能会导致代码变得难以理解。由于它允许在不同的位置之间跳转，程序的执行流程可能会变得令人困惑。</li><li><strong>维护困难：</strong> 当代码库变大并且多人协作时，使用<code>goto</code>语句可能会导致难以维护的代码。在不同的地方使用<code>goto</code>语句会使代码变得难以跟踪和调试。</li><li><strong>可能导致悬挂指针：</strong> 如果不小心使用<code>goto</code>语句，可能会导致指针悬挂，即指针指向了未初始化或已释放的内存区域。</li></ol></blockquote><h3 id="3-4-5替代方案"><a href="#3-4-5替代方案" class="headerlink" title="3.4.5替代方案"></a>3.4.5替代方案</h3><blockquote><p>尽管<code>goto</code>语句在一些情况下可能有用，但在现代编程中，通常更推荐使用结构化的控制流语句，如<code>if</code>、<code>while</code>、<code>for</code>等，来实现逻辑和控制流。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当涉及到控制流语句在C语言中的使用时，我们深入探讨了几种关键的语句：<code>for</code>循环、<code>switch</code>语句、<code>while</code>循环、<code>do-while</code>循环以及<code>goto</code>语句。每种语句都有其独特的优势和适用情况，但在实际编程中，我们需要根据具体情况来选择最适合的控制流结构。</p><blockquote><ul><li><code>for</code> 循环是在已知循环次数的情况下的首选。它的结构清晰，对于循环次数明确的情况下非常有用。</li><li><code>switch</code> 语句在多个选项中进行选择时非常有用。它可以将不同的情况映射到不同的代码块，使代码更具可读性。</li><li><code>while</code> 循环用于在条件为真的情况下重复执行代码。它适用于需要循环直到某个条件不满足的情况。</li><li><code>do-while</code> 循环与 <code>while</code> 循环类似，但它保证循环体至少被执行一次。这对于需要先执行循环体再进行条件检查的场景很有用。</li><li><code>goto</code> 语句是一种无条件跳转工具，尽管它可能在某些情况下有用，但在现代编程中通常应避免使用，以确保代码的可读性和维护性。</li></ul><p>正确选择适当的控制流结构是编写高质量代码的关键一步。无论是迭代次数已知还是需要进行多路分支选择，我们都应根据代码的逻辑和需求来选择合适的结构。同时，结构化的控制流语句有助于提高代码的可读性和维护性，从而促进更好的编程实践。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言初阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言入门初识C语言</title>
      <link href="/2023/09/18/%E3%80%8EC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E3%80%8F%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/09/18/%E3%80%8EC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E3%80%8F%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><strong>在这个数字化时代，计算机编程已经成为连接人类与技术的桥梁。</strong>而在编程的世界中，C语言犹如一座承载着无限可能性的基石。作为计算机编程的经典之选，C语言无疑是每个刚刚踏入编程领域的初学者的理想起点。本篇博客将带您踏上一段奇妙的C语言学习之旅，不仅会教您编写代码，更会启发您深入思考计算机科学的精髓。</p></blockquote><h1 id="C语言简介"><a href="#C语言简介" class="headerlink" title="C语言简介"></a><strong>C语言简介</strong></h1><blockquote><p>C语言是一门古老而强大的编程语言，<strong>诞生于20世纪70年代初</strong>。<strong>由丹尼斯·里奇（Dennis Ritchie）在贝尔实验室开发而成</strong>，C语言一经问世，立即在计算机科学领域引起轰动。其简洁、灵活和高效的特性，使其成为了许多编程任务的首选语言。</p></blockquote><p>C语言既具备高级编程语言的抽象特性，又直接暴露了底层的计算机硬件操作。这种特性使得C语言不仅适用于应用程序的开发，还可用于系统级编程和嵌入式系统的构建。实际上，许多操作系统和编译器本身就是用C语言编写的。🌟</p><p>C语言的<strong>语法简洁而灵活</strong>，<strong>允许程序员进行精细的控制和优化</strong>。它提供了丰富的数据类型，包括整数、浮点数、字符等，以及数组、结构体和指针等数据结构，使得程序员可以更好地管理和组织数据。此外，C语言也<strong>支持低级的内存操作</strong>，使得程序员可以直接操作计算机内存，从而实现高效的算法和数据结构。💡</p><p>尽管C语言在很多方面表现出色，但它也需要<strong>程序员自己负责管理内存</strong>，这可能会导致一些错误和挑战。然而，正是这些挑战培养了程序员的深刻理解和技能，使他们能够编写更加健壮和高性能的程序。</p><h1 id="一、Hello-World！"><a href="#一、Hello-World！" class="headerlink" title="一、Hello World！"></a>一、Hello World！</h1><blockquote><p>在学习任何编程语言时，第一个示例程序通常是经典的”Hello, World!”。它是一个简单的程序，可以帮助你了解基本的语法和程序结构。让我们一起来编写你的第一个C语言程序吧！</p></blockquote><h2 id="1-1-编写代码"><a href="#1-1-编写代码" class="headerlink" title="1.1 编写代码"></a>1.1 编写代码</h2><p>打开你选择的<strong>集成开发环境（IDE）</strong>或者<strong>文本编辑器</strong>，创建一个新的源代码文件，文件名可以是<code>hello.c</code>。然后在文件中输入以下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    printf(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-代码解释"><a href="#1-2-代码解释" class="headerlink" title="1.2 代码解释"></a>1.2 代码解释</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>这是一个<strong>预处理指令</strong>。预处理器会在编译代码<strong>之前</strong>执行，它告诉编译器引入了名为<code>stdio.h</code>的<strong>标准输入输出库</strong>。这个库包含了用于处理输入输出的函数，如<code>printf</code>。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br></pre></td></tr></table></figure><blockquote><p>这是C语言<strong>程序的入口点</strong>。所有C程序都<strong>必须</strong>包含一个名为<code>main</code>的函数，<strong>它是程序的起始执行点</strong>。<code>int</code>表示<code>main</code>函数将返回一个整数值。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>这行代码使用<strong><code>printf</code>函数</strong>打印文本到控制台。<code>printf</code>是C语言中用于<strong>格式化输出的函数</strong>。括号内的内容是你要输出的文本，<strong><code>\n</code>表示换行</strong>。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>return</code>语句</strong>用于指定函数的返回值。<strong>在<code>main</code>函数中</strong>，<strong>通常使用<code>return 0;</code>表示程序执行成功</strong>。其他非零值可能表示程序遇到了错误。</p></blockquote><p><strong>要理解代码的执行过程，你可以将程序想象成一系列的步骤：</strong></p><blockquote><ol><li>预处理器会处理<strong><code>#include &lt;stdio.h&gt;</code></strong>，并将<strong><code>stdio.h</code></strong>中的内容添加到程序中，以便在程序中使用标准输入输出函数。</li><li>当程序开始执行时，它会<strong>跳转</strong>到<code>main</code>函数。<strong><code>main</code>函数是程序的起始点</strong>。</li><li>在<strong><code>main</code></strong>函数中，<strong><code>printf(&quot;Hello, World!\n&quot;);</code></strong>语句会执行。<code>printf</code>函数会将指定的文本打印到控制台。</li><li><strong><code>return 0;</code>表示<code>main</code>函数执行成功</strong>，并返回整数值0，这表示程序<strong>正常终止</strong>。</li><li>整个程序执行完毕，控制台会显示出你的”Hello, World!”消息。</li></ol></blockquote><h2 id="1-3-编译和运行"><a href="#1-3-编译和运行" class="headerlink" title="1.3 编译和运行"></a>1.3 编译和运行</h2><p>保存文件后，你可以使用IDE中的<strong>编译和运行按钮</strong>，或者通过<strong>命令行</strong>运行以下命令来编译和运行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p><strong>第一条命令使用GCC编译器将<code>hello.c</code>源文件编译为可执行文件<code>hello</code>。第二条命令运行生成的可执行文件。</strong></p><h2 id="1-4-结果"><a href="#1-4-结果" class="headerlink" title="1.4 结果"></a>1.4 结果</h2><p>如果一切顺利，你应该能够在控制台看到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p><strong>恭喜你，你已经成功编写并运行了你的第一个C语言程序！</strong>“Hello, World!”程序可能非常简单，但它为你提供了学习C语言的一个良好起点。在接下来的学习中，你将逐步了解更多复杂的语法和概念。</p><h1 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h1><blockquote><p>当你开始学习编程语言时，了解数据类型至关重要，因为<strong>数据类型定义了变量可以存储的数据种类和范围</strong>。在C语言中，有多种基本数据类型，每种类型在内存中占据不同的空间并具有不同的取值范围。以下是一些常见的C语言数据类型的简介：</p></blockquote><h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><ul><li><strong>整数类型</strong>：用于存储整数值，分为<strong>有符号和无符号</strong>两种。有符号整数可以表示正数、负数和零，而无符号整数只能表示非负数（正数和零）。常见整数类型有：<ul><li><code>int</code>：常规整数，<strong>根据平台占用不同字节</strong>。</li><li><code>short</code>：短整数，占用较少字节。</li><li><code>long</code>：长整数，占用较多字节。</li><li><code>unsigned int</code>、<code>unsigned short</code>、<code>unsigned long</code>：无符号整数。</li></ul></li><li><strong>浮点类型</strong>：用于存储小数或实数值，包括<strong>单精度和双精度</strong>。常见浮点类型有：<ul><li><code>float</code>：单精度浮点数，占用4字节。</li><li><code>double</code>：双精度浮点数，占用8字节。</li></ul></li><li><strong>字符类型</strong>：用于存储<strong>单个字符</strong>，通常使用<code>char</code>数据类型。</li></ul><h2 id="2-2-复合数据类型"><a href="#2-2-复合数据类型" class="headerlink" title="2.2 复合数据类型"></a>2.2 复合数据类型</h2><ul><li><strong>数组</strong>：由相同类型的元素组成的集合，通过<strong>索引访问</strong>。例如：<code>int scores[5];</code> 定义一个包含5个整数的数组。</li><li><strong>联合体（Union）</strong>：类似结构体，但<strong>成员共享相同内存</strong>，只能存储一个成员的值，节省内存。</li><li><strong>结构体</strong>：将不同类型的数据组合成自定义的复合数据类型。例如：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> gpa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-指针类型"><a href="#2-3-指针类型" class="headerlink" title="2.3 指针类型"></a>2.3 指针类型</h2><p><strong>指针</strong>：存储变量内存地址，使你能直接访问内存中的数据。指针类型变量可指向特定数据类型。例如：<code>int *ptr;</code> 定义指向整数的指针。</p><h2 id="2-4-枚举类型"><a href="#2-4-枚举类型" class="headerlink" title="2.4 枚举类型"></a>2.4 枚举类型</h2><p><strong>枚举</strong>：定义用户自定义数据类型，限制变量可能取值范围。例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>掌握各种数据类型将帮助你更好地管理数据，有效地创建变量，并确保程序正确性和性能。在C语言中，选择适当的数据类型对于正确使用变量、执行算术运算以及在程序中传递参数至关重要。</p></blockquote><h1 id="三、C语言基础"><a href="#三、C语言基础" class="headerlink" title="三、C语言基础"></a>三、C语言基础</h1><h2 id="3-1-变量和常量"><a href="#3-1-变量和常量" class="headerlink" title="3.1 变量和常量"></a>3.1 变量和常量</h2><ul><li><strong>变量</strong>：在程序中用于存储数据的容器，需要声明并指定其数据类型。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br></pre></td></tr></table></figure><ul><li><strong>常量</strong>：值不可更改的变量，在声明时必须初始化，可以使用<code>const</code>关键字来声明常量。 </li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><h2 id="3-2-运算符"><a href="#3-2-运算符" class="headerlink" title="3.2 运算符"></a>3.2 运算符</h2><ul><li><strong>算术运算符</strong>：用于执行基本算术操作，如加法、减法、乘法和除法。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">10</span> + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>赋值运算符</strong>：用于给变量赋值，将右边的值赋给左边的变量。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>比较运算符</strong>：用于比较两个值，返回布尔值（真或假）。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>逻辑运算符</strong>：用于组合和操作布尔值，如与、或和非。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-控制流语句"><a href="#3-3-控制流语句" class="headerlink" title="3.3 控制流语句"></a>3.3 控制流语句</h2><ul><li><strong>条件语句（if-else）</strong>：根据条件的真假来执行不同的代码块。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    printf(<span class="string">&quot;Pass\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    printf(<span class="string">&quot;Fail\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>循环语句</strong>：重复执行一段代码，有三种主要类型：<code>for</code>、<code>while</code>和<code>do-while</code>。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-注释"><a href="#3-4-注释" class="headerlink" title="3.4 注释"></a>3.4 注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>单行注释用于在一行代码后添加说明。<strong>它从<code>//</code>开始，一直到该行的末尾</strong>。编译器会忽略这些注释，不会将其包含在生成的可执行文件中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">25</span>;  <span class="comment">// 声明并初始化年龄变量</span></span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>多行注释用于跨越多行代码的解释。<strong>它从<code>/\*</code>开始，到<code>\*/</code>结束</strong>。多行注释可以包含多行文本，并且可以用于注释掉一整段代码。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个多行注释示例。</span></span><br><span class="line"><span class="comment">这段代码用于计算两个整数的和。</span></span><br><span class="line"><span class="comment">int sum = num1 + num2;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="注释的作用"><a href="#注释的作用" class="headerlink" title="注释的作用"></a>注释的作用</h3><blockquote><ul><li><strong>解释代码</strong>：注释可以提供代码的解释和上下文，帮助其他人理解你的代码。这对于团队协作和代码维护非常重要。</li><li><strong>记笔记</strong>：你可以使用注释来记录你的想法、思路以及需要后续处理的问题。这有助于你在以后的开发中快速回顾和处理。</li><li><strong>调试</strong>：在调试时，你可以使用注释来排除一些代码，以确定问题是否出现在特定部分。</li><li><strong>临时更改</strong>：如果你想临时禁用某些代码，你可以使用注释来实现，而无需实际删除这些代码。</li></ul></blockquote><h1 id="四、-函数"><a href="#四、-函数" class="headerlink" title="四、 函数"></a>四、 函数</h1><blockquote><p>函数是C语言中的基本构建块之一，它们允许你将一段代码封装为可重用的模块，并通过调用函数来执行特定任务。使用函数可以使你的代码更加模块化、结构化和易于维护。以下是关于函数的一些重要概念：</p></blockquote><h2 id="4-1-函数的声明和定义"><a href="#4-1-函数的声明和定义" class="headerlink" title="4.1  函数的声明和定义"></a>4.1  函数的声明和定义</h2><blockquote><p>在使用函数之前，需要先声明它。函数声明告诉编译器有一个函数存在，但不提供函数的具体实现。函数定义提供了函数的实际代码。例如：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-函数的参数和返回值"><a href="#4-2-函数的参数和返回值" class="headerlink" title="4.2 函数的参数和返回值"></a>4.2 函数的参数和返回值</h2><blockquote><p>函数可以接受参数，执行特定的操作，然后返回一个值。参数是传递给函数的输入值，而返回值是函数执行后的输出结果。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-函数的调用"><a href="#4-3-函数的调用" class="headerlink" title="4.3 函数的调用"></a>4.3 函数的调用</h2><blockquote><p>通过函数名和传递的参数调用函数。调用函数会执行函数的代码，并将返回值返回给调用处。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = square(<span class="number">5</span>); <span class="comment">// 调用square函数，计算5的平方</span></span><br></pre></td></tr></table></figure><h2 id="4-4-主函数（main函数）"><a href="#4-4-主函数（main函数）" class="headerlink" title="4.4 主函数（main函数）"></a>4.4 主函数（main函数）</h2><blockquote><p>每个C程序都必须包含一个名为<code>main</code>的函数。程序从<code>main</code>函数开始执行，当<code>main</code>函数执行完毕时，程序终止。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 主函数的代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-内置函数和自定义函数"><a href="#4-5-内置函数和自定义函数" class="headerlink" title="4.5  内置函数和自定义函数"></a>4.5  内置函数和自定义函数</h2><blockquote><p>C语言提供了许多内置函数，如数学函数、字符串处理函数等。此外，你也可以创建自己的函数来执行特定任务。</p></blockquote><h1 id="五、-数组和字符串"><a href="#五、-数组和字符串" class="headerlink" title="五、 数组和字符串"></a>五、 数组和字符串</h1><blockquote><p>在C语言中，数组和字符串是常用的数据结构，用于存储一组相关的数据。数组是相同类型元素的有序集合，而字符串是字符数组的特殊形式。以下是关于数组和字符串的重要内容：</p></blockquote><h2 id="5-1-数组的声明和初始化"><a href="#5-1-数组的声明和初始化" class="headerlink" title="5.1  数组的声明和初始化"></a>5.1  数组的声明和初始化</h2><blockquote><p>数组的声明需要指定元素的数据类型和元素数量。可以通过下标（索引）访问数组中的元素。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy codeint scores[<span class="number">5</span>]; <span class="comment">// 声明一个包含5个整数的数组</span></span><br><span class="line">scores[<span class="number">0</span>] = <span class="number">85</span>; <span class="comment">// 为数组元素赋值</span></span><br></pre></td></tr></table></figure><p>也可以在声明时进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line"><span class="type">int</span> numbers[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// 声明并初始化一个包含3个整数的数组</span></span><br></pre></td></tr></table></figure><h2 id="5-2-多维数组"><a href="#5-2-多维数组" class="headerlink" title="5.2 多维数组"></a>5.2 多维数组</h2><blockquote><p>多维数组是数组的扩展，可以是二维、三维或更多维度的数组。它们通常用于表示矩阵、表格等数据结构。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cCopy codeint matrix[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-3-字符串"><a href="#5-3-字符串" class="headerlink" title="5.3 字符串"></a>5.3 字符串</h2><blockquote><p>字符串是字符的数组，以null终止字符（’\0’）作为字符串的结尾。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="5-4-字符串处理函数"><a href="#5-4-字符串处理函数" class="headerlink" title="5.4 字符串处理函数"></a>5.4 字符串处理函数</h2><blockquote><p>C语言提供了许多字符串处理函数，用于处理字符串的操作，如连接、比较、复制等。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> source[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> destination[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(destination, source); <span class="comment">// 复制source到destination</span></span><br></pre></td></tr></table></figure><h2 id="5-5-字符串输入和输出"><a href="#5-5-字符串输入和输出" class="headerlink" title="5.5  字符串输入和输出"></a>5.5  字符串输入和输出</h2><blockquote><p>使用<code>scanf</code>函数从用户输入中读取字符串，使用<code>printf</code>函数将字符串输出到控制台。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cCopy codechar name[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入你的名字：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好，%s！\n&quot;</span>, name);</span><br></pre></td></tr></table></figure><p>数组和字符串是C语言中用于存储和操作数据的重要工具。它们在各种编程场景中都得到广泛应用，从简单的存储数据到处理复杂的文本信息。理解数组和字符串的特性和使用方法将有助于你更高效地编写程序。</p><h1 id="六、-指针和内存管理"><a href="#六、-指针和内存管理" class="headerlink" title="六、 指针和内存管理"></a>六、 指针和内存管理</h1><blockquote><p>在C语言中，指针是一个重要的概念，它允许你直接访问内存中的数据，并提供了更高级的内存管理能力。以下是关于指针和内存管理的重要内容：</p></blockquote><h2 id="6-1-指针的概念"><a href="#6-1-指针的概念" class="headerlink" title="6.1 指针的概念"></a>6.1 指针的概念</h2><blockquote><p>指针是存储内存地址的变量。通过指针，你可以直接访问存储在内存中的数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cCopy codeint num = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *ptr;       <span class="comment">// 定义一个指向整数的指针</span></span><br><span class="line">ptr = &amp;num;     <span class="comment">// 将指针指向num的地址</span></span><br></pre></td></tr></table></figure><h2 id="6-2-指针的运算"><a href="#6-2-指针的运算" class="headerlink" title="6.2 指针的运算"></a>6.2 指针的运算</h2><blockquote><p>指针可以进行加法和减法运算，以访问相邻内存单元的数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cCopy codeint numbers[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = numbers; <span class="comment">// 将指针指向数组的第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> thirdValue = *(ptr + <span class="number">2</span>); <span class="comment">// 访问数组的第三个元素，即30</span></span><br></pre></td></tr></table></figure><h4 id="6-3-动态内存分配"><a href="#6-3-动态内存分配" class="headerlink" title="6.3 动态内存分配"></a>6.3 动态内存分配</h4><blockquote><p>C语言允许你在运行时动态分配内存，这样你可以根据需要分配和释放内存。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cCopy codeint *dynamicArray = <span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一个包含5个整数的动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用dynamicArray</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(dynamicArray); <span class="comment">// 释放分配的内存</span></span><br></pre></td></tr></table></figure><h4 id="6-4-指针和数组的关系"><a href="#6-4-指针和数组的关系" class="headerlink" title="6.4 指针和数组的关系"></a>6.4 指针和数组的关系</h4><blockquote><p>数组名实际上是指向数组第一个元素的指针。因此，可以使用指针来访问数组元素。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cCopy codeint numbers[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = numbers;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> firstValue = *ptr; <span class="comment">// 数组的第一个元素，即10</span></span><br><span class="line"><span class="type">int</span> secondValue = *(ptr + <span class="number">1</span>); <span class="comment">// 数组的第二个元素，即20</span></span><br></pre></td></tr></table></figure><p><strong>指针和内存管理是C语言的核心概念之一</strong>，了解它们将帮助你更好地理解内存的工作方式，提高代码的灵活性，并避免内存泄漏等问题。指针的使用虽然强大，但也需要小心谨慎，以避免出现错误。</p><h1 id="七、文件操作和输入-输出"><a href="#七、文件操作和输入-输出" class="headerlink" title="七、文件操作和输入/输出"></a>七、文件操作和输入/输出</h1><blockquote><p>在C语言中，文件操作和输入/输出（I/O）是处理外部数据的关键部分。通过文件操作，你可以读取和写入文件，而输入/输出允许你与用户交互并处理文本。</p></blockquote><h2 id="7-1-文件操作"><a href="#7-1-文件操作" class="headerlink" title="7.1 文件操作"></a>7.1 文件操作</h2><blockquote><p>C语言中的文件操作涉及打开、读取、写入和关闭文件。你可以使用标准库函数来执行这些操作。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *filePointer;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    filePointer = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">// 打开文件以读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (filePointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fgets(data, <span class="number">100</span>, filePointer); <span class="comment">// 从文件读取一行数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    fclose(filePointer); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-格式化输入-输出"><a href="#7-2-格式化输入-输出" class="headerlink" title="7.2 格式化输入/输出"></a>7.2 格式化输入/输出</h2><blockquote><p>使用<code>printf</code>和<code>scanf</code>函数，你可以格式化地输出数据到屏幕和从用户处输入数据。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你的年龄：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你的年龄是：%d\n&quot;</span>, age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-标准输入-输出"><a href="#7-3-标准输入-输出" class="headerlink" title="7.3 标准输入/输出"></a>7.3 标准输入/输出</h2><blockquote><p>C语言中有三个标准的I/O流：<code>stdin</code>（标准输入）、<code>stdout</code>（标准输出）和<code>stderr</code>（标准错误输出）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;这是标准输出\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;这是标准错误输出\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件操作和输入/输出是C语言中处理外部数据的重要组成部分。它们使你能够读取和写入文件，与用户交互，并将程序的结果输出到屏幕上。掌握文件操作和I/O将使你能够创建更丰富的应用程序，能够与外部数据进行有效交互。</p><h1 id="八、错误处理和调试"><a href="#八、错误处理和调试" class="headerlink" title="八、错误处理和调试"></a>八、错误处理和调试</h1><blockquote><p>在编程过程中，错误是不可避免的。C语言提供了一些机制来处理错误并进行调试，以确保程序的正确性和稳定性。</p></blockquote><h2 id="8-1-错误代码"><a href="#8-1-错误代码" class="headerlink" title="8.1  错误代码"></a>8.1  错误代码</h2><blockquote><p>C语言中，通常使用返回值来指示函数是否执行成功，以及在错误发生时提供额外的信息。标准库函数通常会返回特定的错误代码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *filePointer;</span><br><span class="line">    filePointer = fopen(<span class="string">&quot;nonexistent_file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (filePointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(filePointer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2-断言"><a href="#8-2-断言" class="headerlink" title="8.2 断言"></a>8.2 断言</h2><blockquote><p>断言是在代码中添加的条件检查，用于确保程序在满足某些条件时继续执行。如果断言条件不满足，程序将中止并显示错误消息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    assert(x &gt; <span class="number">10</span>); <span class="comment">// 如果x不大于10，程序将中止</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3-调试器"><a href="#8-3-调试器" class="headerlink" title="8.3 调试器"></a>8.3 调试器</h2><blockquote><p>调试器是一种工具，用于追踪程序的执行过程并检查变量的值。在C语言中，你可以使用调试器来识别和修复错误。</p></blockquote><h2 id="8-4-日志和打印调试信息"><a href="#8-4-日志和打印调试信息" class="headerlink" title="8.4 日志和打印调试信息"></a>8.4 日志和打印调试信息</h2><blockquote><p>在程序中添加打印语句或日志，可以帮助你追踪程序的执行，以及查找问题所在。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x的值：%d\n&quot;</span>, x); <span class="comment">// 打印调试信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误处理和调试是开发过程中必不可少的一部分。通过使用适当的错误处理机制和调试工具，你可以更轻松地识别和解决问题，确保程序的正确性和稳定性。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过这篇博客，我们深入了解了C语言的基础知识。从数据类型和变量到控制流语句，再到函数、数组、指针，以及文件操作和调试技巧，我们探索了C语言的核心概念和关键特性。C语言作为一门古老而强大的编程语言，为我们提供了处理底层细节和开发高效程序的工具。</p><blockquote><p>虽然C语言可能对初学者来说有一些挑战，但通过不断的学习、练习和实践，你将逐渐掌握这门语言，并能够编写出高效、健壮的程序。无论是为了系统编程、嵌入式开发、还是学术研究，C语言都是一个极具价值的工具。</p><p>希望这篇博客能够帮助你在C语言的学习之旅中起到一些指引作用。在掌握了这些基础后，你可以继续深入学习更高级的主题，探索更多C语言的应用领域。祝愿你在编程的道路上取得巨大的成功！</p></blockquote><p><strong>如果你有任何问题或需要进一步的帮助，欢迎随时与我交流。继续努力，愿你在编程世界中探索无限可能！</strong></p>]]></content>
      
      
      <categories>
          
          <category> C语言初阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『C语言入门』探索C语言函数</title>
      <link href="/2023/09/18/%E3%80%8EC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E3%80%8F%E6%8E%A2%E7%B4%A2C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/"/>
      <url>/2023/09/18/%E3%80%8EC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E3%80%8F%E6%8E%A2%E7%B4%A2C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><blockquote><p>在现代编程中，函数被视为软件开发的基石，无论是小型脚本还是大型应用程序，都离不开函数的支持。C语言，作为一门广泛使用的编程语言，深刻地体现了<strong>函数在构建可维护、高效和模块化代码方面的重要性</strong>。在本篇博客中，我们将深入探讨C语言函数的各个方面，从基础概念到高级应用，帮助你更好地理解和应用函数。</p></blockquote><h1 id="一、函数概述"><a href="#一、函数概述" class="headerlink" title="一、函数概述"></a>一、函数概述</h1><h2 id="定义与作用"><a href="#定义与作用" class="headerlink" title="定义与作用"></a>定义与作用</h2><blockquote><p>函数是一段封装了特定任务或操作的代码块。它接受输入，执行操作，并可能返回输出。<strong>函数通过将代码逻辑划分为小块，使得问题更易于处理和理解。</strong>这种模块化方法有助于减少代码复杂性，提高代码质量。</p></blockquote><h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><ol><li><strong>模块化和可维护性：</strong> 函数允许将复杂任务分解为更小、更易管理的部分。这种模块化方法使得定位和修复问题更加容易，提高了代码的可维护性。</li><li><strong>代码重用：</strong> 编写一次函数，可以在多处地方调用。这消除了重复编写类似代码的需要，节省了时间和工作量。</li><li><strong>可读性：</strong> 函数将任务划分为逻辑块，使得代码逻辑更加清晰。合理的函数命名和抽象层级可以使代码更易于理解。</li><li><strong>团队协作：</strong> 函数使团队成员能够独立地开发和维护不同的功能模块，提高了团队的效率和协作能力。</li></ol><h1 id="二、函数分类"><a href="#二、函数分类" class="headerlink" title="二、函数分类"></a>二、函数分类</h1><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><blockquote><p>库函数是在C语言中预先定义好的函数，它们提供了许多常见任务的实现方法。这就像一个程序员的工具箱，你可以随时拿来使用，而不必从头开始编写代码。</p></blockquote><ul><li><p><strong>输入输出函数 (<code>stdio.h</code>)：</strong></p><ul><li><code>printf</code>：用于在屏幕上输出格式化的信息。</li><li><code>scanf</code>：用于从键盘读取输入，并根据格式化字符串解析输入。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>数学函数 (<code>math.h</code>)：</strong></p><ul><li><code>sqrt</code>：计算给定数字的平方根。</li><li><code>pow</code>：计算一个数字的指数幂。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> squareRoot = <span class="built_in">sqrt</span>(<span class="number">25.0</span>);</span><br><span class="line">    <span class="type">double</span> power = <span class="built_in">pow</span>(<span class="number">2.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>字符串函数 (<code>string.h</code>)：</strong></p><ul><li><code>strlen</code>：计算字符串的长度。</li><li><code>strcpy</code>：将一个字符串复制到另一个字符串。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str2, str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过使用这些库函数，你可以轻松地执行各种任务，而不必从头编写代码。库函数已经经过<strong>优化和测试</strong>，因此它们可以<strong>提高代码的稳定性和效率。</strong></p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><blockquote><p>自定义函数是你自己编写的、用于完成特定任务的代码块。通过将代码划分为自定义函数，你可以使程序更加模块化和可维护。让我们更详细地了解如何定义、调用和使用自定义函数。</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>自定义函数由程序员根据需要编写，通常包括以下组成部分：</p><blockquote><ul><li><strong>返回类型（Return Type）：</strong> 表示函数返回的数据类型，可以是整数、浮点数、字符等。</li><li><strong>函数名（Function Name）：</strong> 函数的标识符，用于在程序中唯一标识函数。</li><li><strong>参数列表（Parameter List）：</strong> 一组用逗号分隔的参数，用于向函数传递数据。</li><li><strong>函数体（Function Body）：</strong> 包含实际的代码，执行特定的任务。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义函数的定义</span></span><br><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="comment">// 执行任务的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>让我们通过一个例子来演示如何定义和使用自定义函数。我们要编写一个函数，计算两个整数的和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数，计算两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">5</span>, num2 = <span class="number">3</span></span><br><span class="line">    <span class="type">int</span> result = add(num1, num2);  <span class="comment">// 调用自定义函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个示例中，我们首先定义了一个名为 <code>add</code> 的自定义函数。它接受两个整数参数 <code>a</code> 和 <code>b</code>，并在函数体中将它们相加后返回结果。在 <code>main</code> 函数中，我们调用了这个自定义函数，并将 <code>num1</code> 和 <code>num2</code> 作为参数传递给它。最终，我们将结果输出。</p></blockquote><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><blockquote><ul><li><strong>模块化：</strong> 将复杂任务拆分成小块，易于管理和理解。</li><li><strong>重用性：</strong> 编写一次函数，多处调用，避免重复编写代码。</li><li><strong>可读性：</strong> 函数名和功能描述清楚，提高代码可读性。</li><li><strong>维护性：</strong> 修改功能只需在一个地方进行，不影响其他代码。</li></ul></blockquote><h1 id="三、函数参数"><a href="#三、函数参数" class="headerlink" title="三、函数参数"></a>三、函数参数</h1><h2 id="实际参数（实参）"><a href="#实际参数（实参）" class="headerlink" title="实际参数（实参）"></a>实际参数（实参）</h2><blockquote><p>实际参数，也称为实参，是在函数调用时传递给函数的值或变量。它们是函数调用中的真实数据，供函数在执行时使用。实际参数可以是常量、变量、表达式等。</p></blockquote><p>让我们通过一个例子来理解实际参数的概念：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数，计算两个数的平均值</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (num1 + num2) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">10.0</span>, b = <span class="number">20.0</span>;</span><br><span class="line">    <span class="type">double</span> result = average(a, b);  <span class="comment">// 传递实际参数 a 和 b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Average: %lf\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>a</code> 和 <code>b</code> 是实际参数，它们被传递给 <code>average</code> 函数，用于计算平均值。</p><h2 id="形式参数（形参）"><a href="#形式参数（形参）" class="headerlink" title="形式参数（形参）"></a>形式参数（形参）</h2><blockquote><p>形式参数，也称为形参，是在函数定义时声明的参数。它们是函数定义的一部分，用于接收调用函数时传递的实际参数。形式参数在函数体内部被当作变量来使用。</p></blockquote><p>让我们通过一个例子来理解形式参数的概念：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数，计算两个数的平均值</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;  <span class="comment">// 形式参数 num1 和 num2</span></span><br><span class="line">    <span class="keyword">return</span> (num1 + num2) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">10.0</span>, b = <span class="number">20.0</span>;</span><br><span class="line">    <span class="type">double</span> result = average(a, b);  <span class="comment">// 传递实际参数 a 和 b</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Average: %lf\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>num1</code> 和 <code>num2</code> 是形式参数，在函数定义中声明。当函数被调用时，实际参数 <code>a</code> 和 <code>b</code> 会被传递给形式参数。</p><blockquote><p>函数的参数是在函数调用中传递数据的重要方式。<strong>实际参数是函数调用时传递的实际值</strong>，而<strong>形式参数是在函数定义中声明的变量</strong>，用于接收实际参数的值。通过理解参数的作用，你可以更好地控制函数的行为和功能。</p></blockquote><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><strong>实际参数（实参）的内存分配：</strong></p><blockquote><p>实际参数在函数调用时传递给函数，通常通过值传递的方式。这意味着函数接收到的是实参的值的拷贝，而不是实参本身。这样做可以确保函数调用不会影响实参的原始值。</p></blockquote><p><strong>形式参数（形参）的内存分配：</strong> </p><blockquote><p>形式参数在函数定义中声明，用于接收实际参数的值。它们通常是在函数调用时自动分配的局部变量。当函数被调用时，形式参数的内存会被分配，并且在函数执行结束后会被释放。</p></blockquote><p><strong>注意事项：</strong></p><ol><li><strong>值传递和指针传递：</strong> 在C语言中，参数传递可以通过值传递或指针传递来实现。值传递会复制实参的值，而指针传递会传递实参的内存地址。使用指针传递时，函数可以修改实参的值。</li><li><strong>内存开销：</strong> 在函数调用时，每个实参的拷贝都需要一定的内存开销。如果实参很大，多次函数调用可能会导致内存占用过大。这时可以使用指针传递来减少内存开销。</li><li><strong>内存管理：</strong> 如果函数内部动态分配了内存（如使用 <code>malloc</code> 函数），确保在函数结束后释放这些内存，以避免内存泄漏。</li><li><strong>作用域：</strong> 形式参数的作用域仅限于函数内部。它们不能在函数外部访问。而实际参数的作用域是在函数调用的上下文中。</li><li><strong>返回值传递：</strong> 函数的返回值也是通过值传递的方式传递给调用者。如果返回的是一个复杂类型（如结构体），系统会自动处理其复制。</li></ol><blockquote><p>理解实际参数和形式参数在内存上的处理方式，以及值传递和指针传递的区别，对于正确使用函数参数非常重要。合理管理内存，避免内存泄漏，并了解数据在函数调用过程中的传递方式，将有助于编写更健壮和高效的程序。</p></blockquote><h1 id="四、函数调用"><a href="#四、函数调用" class="headerlink" title="四、函数调用"></a>四、函数调用</h1><p>当我们在程序中调用函数时，参数传递的方式会影响函数如何处理数据。让我们更详细地探讨函数的调用方式，以及它们在内存中的操作，通过实例来进一步理解。</p><h2 id="传值调用"><a href="#传值调用" class="headerlink" title="传值调用"></a>传值调用</h2><p>传值调用是一种参数传递方式，意味着<strong>在函数调用时，函数会得到实际参数的一个副本</strong>。这样，函数内部的操作<strong>不会影响原始实际参数的值</strong>。让我们看一个交换两个整数值的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapByValue</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original values: x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    swapByValue(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After swapByValue: x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>swapByValue</code> 函数虽然对 <code>a</code> 和 <code>b</code> 进行了交换，但函数外的 <code>x</code> 和 <code>y</code> 值却没有改变，因为函数得到的是 <code>x</code> 和 <code>y</code> 的复制品。</p><h2 id="传址调用"><a href="#传址调用" class="headerlink" title="传址调用"></a>传址调用</h2><p> 传址调用使用指针传递参数，这意味着<strong>函数获得实际参数的内存地址</strong>。通过操作这些内存地址，<strong>函数可以直接改变实际参数的值</strong>。让我们再次使用交换函数来演示传址调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swapByReference</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original values: x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    swapByReference(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After swapByReference: x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们传递了 <code>x</code> 和 <code>y</code> 的地址给 <code>swapByReference</code> 函数。通过操作这些地址，函数成功地实现了 <code>x</code> 和 <code>y</code> 的交换。</p><h1 id="五、函数嵌套调用与链式访问"><a href="#五、函数嵌套调用与链式访问" class="headerlink" title="五、函数嵌套调用与链式访问"></a>五、函数嵌套调用与链式访问</h1><h2 id="嵌套调用"><a href="#嵌套调用" class="headerlink" title="嵌套调用"></a>嵌套调用</h2><blockquote><p> 函数的嵌套调用是指在一个函数内部调用另一个函数。通过这种方式，你可以将一个大任务分解为更小的子任务，并将其分配给不同的函数来完成。嵌套调用可以使代码更加模块化和可读。</p></blockquote><p>让我们通过一个例子来理解嵌套调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数A：打印数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number: %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数B：调用函数A两次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">callPrintNumberTwice</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    printNumber(num1);</span><br><span class="line">    printNumber(num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    callPrintNumberTwice(x, y); <span class="comment">// 嵌套调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>callPrintNumberTwice</code> 函数在内部两次调用了 <code>printNumber</code> 函数，实现了对两个数字的打印。</p><h2 id="链式访问"><a href="#链式访问" class="headerlink" title="链式访问"></a>链式访问</h2><blockquote><p>链式访问是指在一个表达式中连续调用多个函数。这种方式可以使代码更加紧凑和易于理解，特别适用于一系列相关的操作。</p></blockquote><p>让我们通过一个例子来理解链式访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数A：返回数字的平方</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数B：返回数字的两倍</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">doubleNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = doubleNumber(square(x)); <span class="comment">// 链式访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们在一行中调用了 <code>doubleNumber</code> 函数和 <code>square</code> 函数，实现了对数字的平方和两倍的操作。</p><blockquote><p>函数的嵌套调用和链式访问是提高代码模块化和可读性的有效手段。嵌套调用可以将大任务分解为小任务，使代码更加结构化。链式访问可以在一行代码中完成多个操作，使代码更加紧凑。通过理解这些概念，你可以更好地设计和组织你的程序。</p></blockquote><h1 id="六、函数声明与定义"><a href="#六、函数声明与定义" class="headerlink" title="六、函数声明与定义"></a>六、函数声明与定义</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><blockquote><p>函数声明是在使用函数之前告诉编译器函数的存在和怎么使用。它们包括函数的名称、返回类型和参数列表。通过声明，编译器知道如何正确调用这个函数。</p></blockquote><p>让我们看一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result = add(x, y); <span class="comment">// 使用函数之前进行了声明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们在 <code>main</code> 函数之前声明了 <code>add</code> 函数。这允许我们在 <code>main</code> 函数中调用它，因为编译器知道 <code>add</code> 函数需要两个整数参数并返回一个整数。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><blockquote><p>函数定义是给函数提供<strong>实际的代码实现</strong>，它告诉编译器函数应该做什么。<strong>定义包括函数的名称、返回类型、参数列表和函数体（代码块）。</strong></p></blockquote><p>再看一次例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result = add(x, y); <span class="comment">// 使用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 函数的具体代码实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>add</code> 函数的定义包括函数体中的代码，即实际的加法操作。</p><blockquote><p>函数的声明告诉编译器函数的签名，使得在调用函数之前编译器知道函数的存在和参数。函数的定义提供了函数的具体代码实现。通过这两者，我们可以更好地组织和使用函数。正确的声明和定义对于编写易于维护和理解的代码非常重要。</p></blockquote><h1 id="七、递归"><a href="#七、递归" class="headerlink" title="七、递归"></a>七、递归</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>递归是一种编程技术，它指的是一个函数在其自身内部调用自己。换句话说，递归是一种通过重复将问题分解为更小的相似子问题来解决问题的方法。这种方法特别适用于那些可以被分解成相同类型问题的情况。</p></blockquote><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><blockquote><p>递归的核心思想是将一个大问题分解成一个或多个小问题，然后通过递归调用来解决这些小问题。每次递归调用都会缩小问题的规模，直到问题变得足够小，可以通过简单的方法解决，通常称为<strong>“基本情况”</strong>。</p></blockquote><h2 id="满足条件"><a href="#满足条件" class="headerlink" title="满足条件"></a>满足条件</h2><p>递归的实现需要满足两个主要条件：</p><ol><li><strong>基本情况：</strong> 每个递归函数必须有一个或多个基本情况，即不再递归调用而是直接返回结果的情况。这些基本情况是递归的终止条件，防止函数无限递归。</li><li><strong>递归情况：</strong> 除了基本情况，递归函数在解决问题时会调用自身，但是问题规模会减小，以便最终达到基本情况。</li></ol><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>例子：计算阶乘</strong></p><p>阶乘是一个正整数的所有小于等于它的正整数的乘积。</p><blockquote><ol><li><strong>基本情况：</strong> 基本情况是递归的终止条件。在这个例子中，基本情况是当计算阶乘的数为 0 或 1 时，阶乘结果是 1。这是因为 0 的阶乘和 1 的阶乘都是 1。</li><li><strong>递归情况：</strong> 递归情况是指我们如何将问题分解成更小的子问题。在计算阶乘时，我们将问题分解为计算 <code>(n - 1)!</code>，其中 <code>n</code> 是当前数。这是因为 <code>n!</code> 等于 <code>n</code> 乘以 <code>(n - 1)!</code>。我们通过递归调用来解决 <code>(n - 1)!</code> 这个子问题。</li></ol></blockquote><p>让我们用代码来表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算阶乘</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 基本情况</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>); <span class="comment">// 递归情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> result = factorial(num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Factorial of %d is %d\n&quot;</span>, num, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当我们计算 <code>5!</code> 时，递归会依次计算 <code>4!</code>、<code>3!</code>、<code>2!</code>、<code>1!</code>，直到达到基本情况为止。然后，所有这些部分结果会合并起来得到 <code>5!</code> 的最终结果。</p><p>通过满足基本情况和递归情况，我们能够在递归中解决问题，将问题分解为越来越小的子问题，直到基本情况可以直接返回结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>本篇博客我们深入探讨了C语言中函数的各个方面，从基本概念到高级应用，帮助你更好地理解和运用函数编程。</p></blockquote><ol><li><strong>函数的基本概念：</strong> 我们从函数是什么开始，它是一个独立的代码块，接受输入并产生输出。函数帮助我们将代码模块化，提高可维护性和重用性。</li><li><strong>C语言中函数的分类：</strong><ul><li><strong>库函数：</strong> 库函数是预先定义好的函数，通过 <code>#include</code> 引入库文件就可以使用。我们详细讨论了库函数的使用和目的。</li><li><strong>自定义函数：</strong> 自定义函数由程序员编写，用于解决特定问题。我们探讨了如何定义和调用自定义函数，并通过例子展示了它们的用法。</li></ul></li><li><strong>函数的参数：</strong> 我们讨论了实际参数和形式参数，以及在函数调用过程中内存上的注意事项。函数参数是传递数据和信息的桥梁，正确的参数使用对于函数的正确运行至关重要。</li><li><strong>函数的调用：</strong> 我们详细介绍了传值调用和传址调用，通过举例说明了它们的不同。理解这些调用方式有助于我们更好地控制函数之间的数据传递和交互。</li><li><strong>函数的嵌套调用和链式访问：</strong> 嵌套调用和链式访问是函数调用的进阶技巧。我们阐述了它们的概念，并通过例子解释了如何在程序中应用它们，提高代码的模块化和紧凑性。</li><li><strong>函数的声明和定义：</strong> 函数的声明和定义是代码组织中的关键。我们解释了函数声明和定义的目的，以及它们如何帮助我们在程序中正确地使用函数。</li><li><strong>函数递归：</strong> 递归是一种强大的编程技巧，通过在函数内部调用自身来解决问题。我们详细讨论了递归的概念、两个必要条件以及与迭代的对比，通过计算阶乘的例子来阐述递归的工作原理。</li></ol><blockquote><p>通过这篇博客，你应该对C语言中函数的各个方面有了更深入的理解。函数是编程的基础，掌握好函数的使用和原理将帮助你编写更加清晰、模块化和高效的代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言初阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『C语言入门』数组详解</title>
      <link href="/2023/09/18/%E3%80%8EC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E3%80%8F%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/09/18/%E3%80%8EC%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E3%80%8F%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>数组在C语言编程中扮演着重要角色，它们让我们能够高效地存储和管理数据。本文将带您探索一维数组，学习如何创建、初始化和使用数组，以及它们在计算机内存中的存储方式。让我们深入了解C语言中这个基础而强大的概念。</p></blockquote><h1 id="一、一维数组"><a href="#一、一维数组" class="headerlink" title="一、一维数组"></a>一、一维数组</h1><h2 id="1-1-数组的创建"><a href="#1-1-数组的创建" class="headerlink" title="1.1 数组的创建"></a>1.1 数组的创建</h2><p>在C语言中，数组是一种用于存储同类型数据元素的线性数据结构。当创建一个数组时，涉及到以下细节：</p><ul><li><strong>类型和名称：</strong> 首先，你需要确定数组的数据类型（整数、浮点数、字符等）以及为数组命名，这将用于在代码中引用数组。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如，创建一个能容纳5个整数的数组</span></span><br><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>大小的声明：</strong> 通过方括号中的数字来定义数组的大小，这决定了数组可以容纳的元素数量。数组的大小在创建后通常是固定的。</li></ul><h2 id="1-2-数组的初始化"><a href="#1-2-数组的初始化" class="headerlink" title="1.2 数组的初始化"></a>1.2 数组的初始化</h2><p>数组初始化是指在创建数组的同时为数组的每个元素赋予初始值。这里有一些更深入的方面需要考虑：</p><ul><li><strong>显式初始化：</strong> 你可以在创建数组时使用花括号为数组的每个元素提供初始值。这些值按照你提供的顺序分配给数组元素。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并初始化一个整数数组</span></span><br><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>部分初始化和默认值：</strong> 如果未为数组的所有元素提供初始值，剩余的元素将被自动设置为默认值，例如，整数数组中未初始化的元素将被设置为0。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前三个元素被初始化为1、2、3，剩余的元素自动设为0</span></span><br><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-3-一维数组的使用"><a href="#1-3-一维数组的使用" class="headerlink" title="1.3  一维数组的使用"></a>1.3  一维数组的使用</h2><p>了解如何使用数组中的元素以及如何遍历数组对于编程至关重要。这里有更多的细节要考虑：</p><ul><li><strong>通过索引访问：</strong> 数组中的元素通过索引来访问，索引从0开始，表示数组中的第一个元素。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> thirdElement = myArray[<span class="number">2</span>];  <span class="comment">// 获取第三个元素（索引为2）</span></span><br></pre></td></tr></table></figure><ul><li><strong>遍历数组：</strong> 使用循环（如for循环）可以遍历数组中的所有元素，进行操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myArray[i]);  <span class="comment">// 打印数组的所有元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-一维数组在内存中的存储"><a href="#1-4-一维数组在内存中的存储" class="headerlink" title="1.4  一维数组在内存中的存储"></a>1.4  一维数组在内存中的存储</h2><h3 id="1-4-1-内存中的数组布局"><a href="#1-4-1-内存中的数组布局" class="headerlink" title="1.4.1  内存中的数组布局"></a>1.4.1  内存中的数组布局</h3><p>在C语言中，一维数组的元素是按照顺序在内存中连续存储的。这种连续存储的布局有助于高效的内存访问，同时也决定了数组元素之间的关系。</p><ul><li><strong>数据类型的大小：</strong> 在理解内存布局之前，需要知道数组元素的数据类型的大小，例如，int类型通常是4字节。</li></ul><h3 id="1-4-2-计算元素的内存地址"><a href="#1-4-2-计算元素的内存地址" class="headerlink" title="1.4.2  计算元素的内存地址"></a>1.4.2  计算元素的内存地址</h3><p>了解如何计算数组元素的内存地址对于深入理解内存布局至关重要。数组的内存地址可以通过数组的起始地址加上索引乘以每个元素的大小来计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设myArray在内存中的起始地址是1000</span></span><br><span class="line"><span class="comment">// 每个整数占用4个字节</span></span><br><span class="line"><span class="comment">// 计算第三个元素（索引为2）的内存地址</span></span><br><span class="line"><span class="type">int</span> thirdElementAddress = &amp;myArray[<span class="number">2</span>];  <span class="comment">// 1000 + 2 * 4 = 1008</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3-内存中的数组可视化"><a href="#1-4-3-内存中的数组可视化" class="headerlink" title="1.4.3  内存中的数组可视化"></a>1.4.3  内存中的数组可视化</h3><p>想象一下，你有一个整数数组<code>myArray</code>，包含5个元素。在内存中，它可能像这样布局：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址    元素值 (每个元素占<span class="number">4</span>字节)</span><br><span class="line"><span class="number">1000</span>       <span class="selector-attr">[0]</span></span><br><span class="line"><span class="number">1004</span>       <span class="selector-attr">[1]</span></span><br><span class="line"><span class="number">1008</span>       <span class="selector-attr">[2]</span></span><br><span class="line"><span class="number">1012</span>       <span class="selector-attr">[3]</span></span><br><span class="line"><span class="number">1016</span>       <span class="selector-attr">[4]</span></span><br></pre></td></tr></table></figure><p>从上面的布局中可以看出，第一个元素位于起始地址1000，而每个元素都相对于前一个元素的地址增加了4个字节。这就是数组连续存储的本质。</p><h3 id="1-4-4-指针与数组的关系"><a href="#1-4-4-指针与数组的关系" class="headerlink" title="1.4.4 指针与数组的关系"></a>1.4.4 指针与数组的关系</h3><p>指针在理解数组的内存存储中起着重要作用。数组名本身就是一个指向数组起始位置的指针，可以用于访问数组中的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = myArray;  <span class="comment">// ptr指向数组的起始位置</span></span><br><span class="line"><span class="type">int</span> thirdElement = *(ptr + <span class="number">2</span>);  <span class="comment">// 通过指针访问第三个元素的值</span></span><br></pre></td></tr></table></figure><h3 id="1-5-5-内存布局的影响"><a href="#1-5-5-内存布局的影响" class="headerlink" title="1.5.5  内存布局的影响"></a>1.5.5  内存布局的影响</h3><blockquote><p>了解数组的内存布局对于编程至关重要，因为它影响了程序的性能。连续的内存布局允许CPU高效地预取和缓存数组元素，从而提高访问速度。</p></blockquote><h1 id="二、二维数组"><a href="#二、二维数组" class="headerlink" title="二、二维数组"></a>二、二维数组</h1><h2 id="2-1-二维数组的创建"><a href="#2-1-二维数组的创建" class="headerlink" title="2.1 二维数组的创建"></a>2.1 二维数组的创建</h2><blockquote><p>二维数组是一种表格状的数据结构，可以将其视为行和列的组合。在C语言中，创建二维数组包括指定数组的类型和名称，以及行数和列数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个3行4列的整数类型的二维数组</span></span><br><span class="line"><span class="type">int</span> myArray[<span class="number">3</span>][<span class="number">4</span>];  <span class="comment">// 声明一个名为myArray的3行4列整数二维数组</span></span><br></pre></td></tr></table></figure><h2 id="2-2-二维数组的初始化"><a href="#2-2-二维数组的初始化" class="headerlink" title="2.2 二维数组的初始化"></a>2.2 二维数组的初始化</h2><blockquote><p>初始化二维数组是在创建数组的同时为每个元素赋予初始值。这可能需要更多的关注，尤其是在初始化多维数组时。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并初始化一个3行4列的整数二维数组</span></span><br><span class="line"><span class="type">int</span> myArray[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,   <span class="comment">// 第一行的元素</span></span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,   <span class="comment">// 第二行的元素</span></span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125; <span class="comment">// 第三行的元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3-二维数组的使用"><a href="#2-3-二维数组的使用" class="headerlink" title="2.3 二维数组的使用"></a>2.3 二维数组的使用</h2><blockquote><p>使用二维数组涉及到通过行索引和列索引来访问元素。这些索引从0开始，表示数组中的第一个行或列。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = myArray[<span class="number">1</span>][<span class="number">2</span>];  <span class="comment">// 获取第二行、第三列的元素值（行索引为1，列索引为2）</span></span><br></pre></td></tr></table></figure><p>你可以使用嵌套循环来遍历整个二维数组，进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, myArray[i][j]);  <span class="comment">// 打印整个二维数组的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  <span class="comment">// 换行以区分行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-二维数组在内存中的存储"><a href="#2-4-二维数组在内存中的存储" class="headerlink" title="2.4 二维数组在内存中的存储"></a>2.4 二维数组在内存中的存储</h2><blockquote><p>深入了解二维数组在内存中的存储方式有助于更好地理解其索引和访问方式。</p></blockquote><ul><li><strong>连续存储：</strong> 在内存中，二维数组的元素实际上是以一维数组的形式连续存储的，每一行的元素排列在一起，行与行之间相邻。</li><li><strong>内存地址计算：</strong> 计算二维数组中元素的内存地址需要使用起始地址、行索引、列数以及每个元素的大小。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设myArray在内存中的起始地址是2000</span></span><br><span class="line"><span class="comment">// 每个整数占用4个字节</span></span><br><span class="line"><span class="comment">// 计算第二行第三列（行索引为1，列索引为2）的内存地址</span></span><br><span class="line"><span class="type">int</span> elementAddress = &amp;myArray[<span class="number">1</span>][<span class="number">2</span>];  <span class="comment">// 2000 + 1 * 4 * 4 + 2 * 4 = 2024</span></span><br></pre></td></tr></table></figure><p>这样的存储方式允许C语言模拟实现了二维数组的访问。</p><h1 id="三、数组越界"><a href="#三、数组越界" class="headerlink" title="三、数组越界"></a>三、数组越界</h1><h2 id="3-1-数组越界的问题和风险"><a href="#3-1-数组越界的问题和风险" class="headerlink" title="3.1 数组越界的问题和风险"></a>3.1 数组越界的问题和风险</h2><p>数组越界是指试图访问数组之外的元素，这可能会导致以下问题和风险：</p><blockquote><ol><li><strong>未定义行为（Undefined Behavior）：</strong> C语言标准中未定义了数组越界的行为。这意味着当你访问超出数组范围的元素时，编译器不会为此提供任何保证，程序可能会表现出无法预测的结果，包括崩溃、输出错误的值，甚至在不同情况下可能有不同的行为。</li><li><strong>内存损坏：</strong> 越界访问可能会影响到数组元素以外的内存区域。这可能会导致内存损坏，导致数据的意外改变，影响到其他变量或程序的执行。</li><li><strong>安全漏洞：</strong> 数组越界访问是缓冲区溢出等安全漏洞的常见原因之一。攻击者可能会通过越界访问来修改其他关键变量的值，执行恶意代码，甚至窃取敏感数据。</li></ol></blockquote><h2 id="3-2-避免数组越界"><a href="#3-2-避免数组越界" class="headerlink" title="3.2 避免数组越界"></a>3.2 避免数组越界</h2><p>为了避免数组越界，有一些实用的方法和最佳实践：</p><ol><li><strong>检查索引范围：</strong> 在访问数组元素之前，始终检查索引是否在合法的范围内。可以使用条件语句来验证索引的有效性。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; arrayLength) &#123;</span><br><span class="line">    <span class="comment">// 执行数组元素访问操作</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理越界情况，如报错或返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>使用循环：</strong> 在使用循环遍历数组时，确保循环的索引在合法范围内。循环条件应考虑数组长度。</li><li><strong>注意多维数组：</strong> 对于多维数组，确保每个维度的索引都在有效范围内。例如，对于 <code>int myArray[3][4];</code>，确保行索引在0到2之间，列索引在0到3之间。</li><li><strong>使用<code>sizeof</code>：</strong> 在使用数组时，可以使用 <code>sizeof</code> 运算符来获取数组的大小，以便进行索引的合法性检查。</li></ol><h1 id="四、数组作为函数参数"><a href="#四、数组作为函数参数" class="headerlink" title="四、数组作为函数参数"></a>四、数组作为函数参数</h1><blockquote><p>当数组作为函数参数传递时，数组名是一个指向数组首元素内存地址的常量指针。数组名实际上被解释为指向数组首元素的指针，这使得函数能够访问整个数组。</p></blockquote><p>让我们更详细地解释：</p><h2 id="4-1-数组名是指向首元素的指针"><a href="#4-1-数组名是指向首元素的指针" class="headerlink" title="4.1 数组名是指向首元素的指针"></a>4.1 数组名是指向首元素的指针</h2><blockquote><p>在C语言中，数组名是一个指向数组首元素的<strong>常量指针</strong>。这意味着数组名实际上是首元素的内存地址。当你将数组作为函数参数传递时，函数会接收数组名，并将其视为指向数组首元素的指针。</p></blockquote><p>考虑以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里，arr 是一个指向数组首元素的指针</span></span><br><span class="line">    <span class="comment">// 它与 &amp;arr[0] 是等价的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);  <span class="comment">// 通过指针运算访问数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    printArray(myArray, <span class="number">5</span>);  <span class="comment">// 传递数组名和数组大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，当我们传递 <code>myArray</code> 到 <code>printArray</code> 函数时，<code>arr</code> 在函数内部实际上被视为指向 <code>myArray</code> 首元素的指针。因此，通过 <code>arr[i]</code> 的方式可以访问数组元素。</p><h2 id="4-2-数组名在函数参数中的特性"><a href="#4-2-数组名在函数参数中的特性" class="headerlink" title="4.2 数组名在函数参数中的特性"></a>4.2 数组名在函数参数中的特性</h2><p>当数组名作为函数参数传递时，有一些关键特性需要注意：</p><ul><li>数组名会退化为指向首元素的指针。在函数参数声明中，<code>int arr[]</code> 实际上被理解为 <code>int *arr</code>，因此 <code>arr</code> 是一个指针。</li><li>由于传递的是指针，函数内部无法直接获取传递的数组大小。通常需要将数组大小作为额外的参数传递给函数，以避免越界访问。</li></ul><h2 id="4-3-避免数组越界"><a href="#4-3-避免数组越界" class="headerlink" title="4.3 避免数组越界"></a>4.3 避免数组越界</h2><blockquote><p>在函数参数中传递数组时，必须特别注意数组越界问题。由于函数无法获取传递数组的确切大小，因此在函数内部应使用传递的数组大小来避免越界访问。</p></blockquote><h2 id="4-4-数组名与指针的差异"><a href="#4-4-数组名与指针的差异" class="headerlink" title="4.4 数组名与指针的差异"></a>4.4 数组名与指针的差异</h2><p>尽管数组名在函数参数中退化为指针，但数组名和指针之间仍然存在一些差异：</p><ul><li>数组名是常量指针，一旦指向某个内存地址，就无法再指向其他地方。而指针变量可以重新赋值为其他内存地址。</li><li>数组名可以使用 <code>sizeof</code> 运算符来获取整个数组的大小，而指针只能获取指针本身的大小。</li></ul><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><blockquote><p>通过本文的探讨，我们深入了解了在C语言中创建、初始化和使用一维数组的过程，同时还探讨了二维数组的相关内容。此外，我们还研究了数组越界问题以及如何将数组作为函数参数传递。以下是我们从这篇文章中所获得的关键信息：</p></blockquote><h2 id="5-1-一维数组的重要性和使用"><a href="#5-1-一维数组的重要性和使用" class="headerlink" title="5.1 一维数组的重要性和使用"></a>5.1 一维数组的重要性和使用</h2><blockquote><ul><li>一维数组是C语言中的重要数据结构，用于有效地存储和管理一系列相同类型的数据。</li><li>创建数组时，我们需要指定数据类型、数组名称和大小。</li><li>数组可以通过显式初始化来设置初始值，也可以部分初始化，未初始化的元素会被设为默认值。</li><li>数组中的元素可以通过索引进行访问，索引从0开始，通过循环遍历数组可以实现对每个元素的操作。</li><li>数组在内存中是连续存储的，可以通过内存地址计算和指针来访问元素。</li></ul></blockquote><h2 id="5-2-二维数组的构建和使用"><a href="#5-2-二维数组的构建和使用" class="headerlink" title="5.2 二维数组的构建和使用"></a>5.2 二维数组的构建和使用</h2><blockquote><ul><li>二维数组是表格状的数据结构，适用于需要表示行和列关系的情况。</li><li>创建二维数组时，除了数据类型和名称，还需要确定行数和列数。</li><li>通过提供初始化值来初始化二维数组，每个元素通过行索引和列索引定位。</li><li>二维数组的访问也是通过双重索引实现的，行和列索引都从0开始。</li></ul></blockquote><h2 id="5-3-避免数组越界问题"><a href="#5-3-避免数组越界问题" class="headerlink" title="5.3 避免数组越界问题"></a>5.3 避免数组越界问题</h2><blockquote><ul><li>数组越界指试图访问数组范围之外的元素，可能导致未定义行为、内存损坏和安全漏洞。</li><li>可以通过检查索引范围、使用循环时确保索引在有效范围内，以及使用<code>sizeof</code>运算符来避免数组越界问题。</li></ul></blockquote><h2 id="5-4-数组作为函数参数的特性"><a href="#5-4-数组作为函数参数的特性" class="headerlink" title="5.4 数组作为函数参数的特性"></a>5.4 数组作为函数参数的特性</h2><blockquote><ul><li>数组名作为函数参数时，实际上是传递了一个指向数组首元素的常量指针。</li><li>在函数参数中，数组名退化为指针，无法直接获取数组大小，需要通过额外参数传递。</li><li>了解数组名在函数参数中的特性有助于正确处理数组的大小和越界问题。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言初阶 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『MySQL』MySQL安装</title>
      <link href="/2023/09/18/%E3%80%8EMySQL%E3%80%8FMySQL%E5%AE%89%E8%A3%85/"/>
      <url>/2023/09/18/%E3%80%8EMySQL%E3%80%8FMySQL%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h1><blockquote><ul><li>此教程面向<strong><code>Centos7</code></strong>版本操作系统。</li><li>卸载安装均在<code>root</code>用户下进行，其他用户均能使用。</li><li>前期教学在<code>roo</code>t用户下，熟悉相关操作等，后续切换至普通用户。</li></ul></blockquote><h1 id="卸载内置环境"><a href="#卸载内置环境" class="headerlink" title="卸载内置环境"></a>卸载内置环境</h1><blockquote><p><strong>若读者环境配置完善可跳过此教程。</strong></p></blockquote><h2 id="检测mriadb与mysql进程"><a href="#检测mriadb与mysql进程" class="headerlink" title="检测mriadb与mysql进程"></a>检测<code>mriadb</code>与<code>mysql</code>进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># ps axj | grep mariadb | grep -v grep</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># ps axj | grep mysql | grep -v grep</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><blockquote><p>没有显示任何输出，<code>grep</code>命令都没有找到匹配的进程。意味着系统中没有运行中的与<code>mariadb</code>或<code>mysql</code>相关的进程。</p></blockquote><p><strong>若读者的系统中有其中服务，可执行下列指令停止相关服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mariadb.service <span class="comment"># 停⽌mariadb 服务</span></span><br><span class="line">systemctl stop mysqld <span class="comment"># 停⽌mysql 服务</span></span><br></pre></td></tr></table></figure><p>命令使用<code>systemctl</code>工具，该工具用于管理系统的Systemd服务。<strong>请注意，MariaDB和MySQL是两种不同的数据库管理系统，因此你需要根据实际安装在系统上的数据库服务来选择停止的命令。</strong></p><ul><li><code>systemctl stop mariadb.service</code>：这个命令用于停止MariaDB服务。MariaDB是一个MySQL分支，所以它的服务通常被命名为<code>mariadb.service</code>。</li><li><code>systemctl stop mysqld</code>：这个命令用于停止MySQL服务。MySQL的服务通常被命名为<code>mysqld</code>或类似的名称。</li></ul><h2 id="检查系统安装包"><a href="#检查系统安装包" class="headerlink" title="检查系统安装包"></a>检查系统安装包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># rpm -qa | grep mariadb</span></span><br><span class="line">mariadb-libs-5.5.68-1.el7.x86_64</span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># rpm -qa | grep mysql</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><ol><li><code>rpm -qa | grep mariadb</code>：这个命令使用<code>rpm</code>工具查询已安装的软件包，并通过管道将结果传递给<code>grep</code>命令，以查找包含字符串<code>mariadb</code>的软件包。根据输出，系统已安装了一个名为<code>mariadb-libs-5.5.68-1.el7.x86_64</code>的软件包，这是<code>Mariadb</code>数据库的库文件。</li><li><code>rpm -qa | grep mysql</code>：输出中，没有找到任何匹配项，这意味着系统中没有安装任何名为<code>mysql</code>的软件包。</li></ol><h2 id="卸载这些默认安装包"><a href="#卸载这些默认安装包" class="headerlink" title="卸载这些默认安装包"></a>卸载这些默认安装包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># rpm -qa | grep mariadb | xargs yum -y remove</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># rpm -qa | grep mmysql | xargs yum -y remove</span></span><br></pre></td></tr></table></figure><p>这个命令使用一系列Linux命令来卸载（删除）与”Mariadb”相关的软件包。<strong>（mysql相关指令同理）</strong></p><ol><li><p><code>rpm -qa | grep mariadb</code>：这部分命令使用<code>rpm</code>工具来查询已安装的软件包列表（<code>rpm -qa</code>），然后通过管道(<code>|</code>)将结果传递给<code>grep</code>命令。<code>grep</code>命令用于筛选包含字符串<code>mariadb</code>的软件包。这将列出与Mariadb相关的所有已安装软件包。</p></li><li><p><code>xargs</code>：<code>xargs</code>命令用于将前一步的输出（即已安装的Mariadb相关软件包的列表）作为参数传递给下一个命令。</p></li><li><p><code>yum -y remove</code>：这部分命令使用<code>yum</code>工具来卸载（删除）指定的软件包。<code>-y</code>选项表示在卸载时<strong>不需要用户确认</strong>，直接进行卸载操作。<code>remove</code>命令后面需要指定要卸载的软件包。</p></li></ol><p>所以，这个命令的整体目的是列出并卸载所有与Mariadb相关的已安装软件包。通过使用<code>rpm</code>和<code>grep</code>命令，它列出与Mariadb相关的软件包，然后使用<code>xargs</code>将它们传递给<code>yum -y remove</code>来进行卸载操作。这将自动删除与Mariadb相关的所有软件包而不需要用户手动确认。</p><h1 id="获取mysql官⽅yum源"><a href="#获取mysql官⽅yum源" class="headerlink" title="获取mysql官⽅yum源"></a>获取<code>mysql</code>官⽅<code>yum</code>源</h1><blockquote><p>获取mysql官⽅yum源: <a href="http://repo.mysql.com/">http://repo.mysql.com/</a></p><p>注意：最好安装与系统⼀致的mysql版本，否则可能会存在软件兼容性问题。</p></blockquote><h2 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># cat /etc/redhat-release </span></span><br><span class="line">CentOS Linux release 7.6.1810 (Core) </span><br></pre></td></tr></table></figure><p><strong>获取系统版本之后在官方源上下载对应版本上传至Linux服务器。</strong></p><blockquote><p><strong>笔者下载版本：<code>mysql57-community-release-el7.rpm</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># ls</span></span><br><span class="line">mysql57-community-release-el7.rpm</span><br></pre></td></tr></table></figure><p><code>mysql57-community-release-el7.rpm</code>是MySQL 5.7社区版的安装仓库文件（Repository RPM），用于在CentOS 7及其衍生版本上安装MySQL 5.7社区版。这个Repository RPM包含了MySQL 5.7数据库服务器的安装源配置信息，使你可以使用<code>yum</code>或<code>dnf</code>等包管理工具轻松安装MySQL 5.7。</p><h2 id="安装mysql-yum-源"><a href="#安装mysql-yum-源" class="headerlink" title="安装mysql yum 源"></a>安装<code>mysql</code> <code>yum</code> 源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地的yum源</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># ls /etc/yum.repos.d/ -al</span></span><br><span class="line">total 32</span><br><span class="line">drwxr-xr-x.  2 root root  4096 Sep 26 07:51 .</span><br><span class="line">drwxr-xr-x. 93 root root 12288 Sep 27 23:53 ..</span><br><span class="line">-rw-r--r--   1 root root   614 Sep 25 22:12 CentOS-Base.repo</span><br><span class="line">-rw-r--r--   1 root root   230 Sep 25 22:12 CentOS-Epel.repo</span><br><span class="line">-rw-r--r--   1 root root  1358 Sep  5  2021 epel.repo</span><br><span class="line">-rw-r--r--   1 root root  1457 Sep  5  2021 epel-testing.repo</span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="built_in">cd</span> MySQL</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># rpm -ivh mysql57-community-release-el7.rpm</span></span><br><span class="line">warning: mysql57-community-release-el7.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                          <span class="comment">################################# [100%]</span></span><br><span class="line">Updating / installing...</span><br><span class="line">   1:mysql57-community-release-el7-11 <span class="comment">################################# [100%]</span></span><br><span class="line"><span class="comment"># 安装后再次查看</span></span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># ls /etc/yum.repos.d/ -al</span></span><br><span class="line">total 40</span><br><span class="line">drwxr-xr-x.  2 root root  4096 Sep 28 00:17 .</span><br><span class="line">drwxr-xr-x. 93 root root 12288 Sep 27 23:53 ..</span><br><span class="line">-rw-r--r--   1 root root   614 Sep 25 22:12 CentOS-Base.repo</span><br><span class="line">-rw-r--r--   1 root root   230 Sep 25 22:12 CentOS-Epel.repo</span><br><span class="line">-rw-r--r--   1 root root  1358 Sep  5  2021 epel.repo</span><br><span class="line">-rw-r--r--   1 root root  1457 Sep  5  2021 epel-testing.repo</span><br><span class="line">-rw-r--r--   1 root root  1838 Apr 27  2017 mysql-community.repo</span><br><span class="line">-rw-r--r--   1 root root  1885 Apr 27  2017 mysql-community-source.repo</span><br></pre></td></tr></table></figure><ol><li><p><code>ls /etc/yum.repos.d/ -al</code>：这个命令用于列出<code>/etc/yum.repos.d/</code>目录中的所有文件和子目录的详细信息，包括权限、所有者、文件大小等。这个命令的目的是查看当前系统中已有的yum仓库配置文件。</p></li><li><p><code>rpm -ivh mysql57-community-release-el7.rpm</code>：这个命令使用<code>rpm</code>工具来安装名为<code>mysql57-community-release-el7.rpm</code>的MySQL 5.7的yum仓库配置文件。具体来说：</p><ul><li><code>-i</code>选项表示安装软件包。</li><li><code>-v</code>选项表示在执行安装时显示详细信息。</li><li><code>-h</code>选项表示以哈希标记的形式显示安装进度。</li><li><code>mysql57-community-release-el7.rpm</code>是要安装的Repository RPM文件的名称。</li></ul><p>安装Repository RPM文件后，系统将获得与MySQL 5.7相关的软件包信息，可以使用<code>yum</code>命令来安装MySQL 5.7。</p></li><li><p>最后，<code>ls /etc/yum.repos.d/ -al</code>命令再次执行，以确认MySQL 5.7的yum仓库配置文件已成功添加到<code>/etc/yum.repos.d/</code>目录中。从输出中可以看到，两个新的Repository RPM文件<code>mysql-community.repo</code>和<code>mysql-community-source.repo</code>已经存在，这表示MySQL 5.7的yum仓库配置已经添加到系统中。</p></li></ol><blockquote><p>目的是准备系统以安装MySQL 5.7，包括添加MySQL 5.7的yum仓库配置文件以及确认它们已经成功添加到系统中。接下来，可以使用<code>yum</code>命令来安装MySQL 5.7或其他MySQL相关的软件包。</p></blockquote><h2 id="检测能否正常工作"><a href="#检测能否正常工作" class="headerlink" title="检测能否正常工作"></a>检测能否正常工作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># yum list | grep mysql</span></span><br><span class="line">Repository epel is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">mysql57-community-release.noarch         el7-11                        installed</span><br><span class="line">akonadi-mysql.x86_64                     1.9.2-4.el7                   os       </span><br><span class="line">anope-mysql.x86_64                       2.0.14-1.el7                  epel     </span><br><span class="line">apr-util-mysql.x86_64                    1.5.2-6.el7_9.1               updates  </span><br><span class="line">calligra-kexi-driver-mysql.x86_64        2.9.10-2.el7                  epel     </span><br><span class="line">collectd-mysql.x86_64                    5.8.1-1.el7                   epel     </span><br><span class="line">dmlite-plugins-mysql.x86_64              1.15.2-15.el7                 epel     </span><br><span class="line">dovecot-mysql.x86_64                     1:2.2.36-8.el7                os       </span><br><span class="line">dpm-copy-server-mysql.x86_64             1.13.0-1.el7                  epel     </span><br><span class="line">dpm-name-server-mysql.x86_64             1.13.0-1.el7                  epel     </span><br><span class="line">dpm-server-mysql.x86_64                  1.13.0-1.el7                  epel     </span><br><span class="line">dpm-srm-server-mysql.x86_64              1.13.0-1.el7                  epel     </span><br><span class="line">dspam-mysql.x86_64                       3.10.2-12.el7                 epel     </span><br><span class="line">...</span><br><span class="line"><span class="comment"># 能看到上列信息即可</span></span><br></pre></td></tr></table></figure><h1 id="安装mysql服务"><a href="#安装mysql服务" class="headerlink" title="安装mysql服务"></a>安装<code>mysql</code>服务</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># yum install -y mysql-community-server</span></span><br><span class="line"><span class="comment"># 若结尾出现报错</span></span><br><span class="line">Public key <span class="keyword">for</span> mysql-community-server-5.7.43-1.el7.x86_64.rpm is not installed</span><br><span class="line"> Failing package is: mysql-community-server-5.7.43-1.el7.x86_64</span><br><span class="line"> GPG Keys are configured as: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br><span class="line"> <span class="comment"># 解决方案</span></span><br><span class="line"> rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br><span class="line"> <span class="comment"># 终端输入并再次执行安装指令即可</span></span><br><span class="line"> <span class="comment"># 安装成功</span></span><br><span class="line"> Installed:</span><br><span class="line">  mysql-community-server.x86_64 0:5.7.43-1.el7                                                                     </span><br><span class="line">Dependency Installed:</span><br><span class="line">  mysql-community-client.x86_64 0:5.7.43-1.el7   mysql-community-common.x86_64 0:5.7.43-1.el7   mysql-community-libs.x86_64 0:5.7.43-1.el7  </span><br><span class="line"></span><br><span class="line">Complete!</span><br></pre></td></tr></table></figure><p>当尝试使用 <code>yum</code> 包管理器安装 MySQL Community Server 时，系统会尝试验证软件包的<strong>完整性和安全性</strong>，以确保它来自受信任的源。这个验证过程包括检查数字签名，以确保软件包没有被篡改或损坏。如果系统不具备安装软件包所需的 <strong>GPG（GNU Privacy Guard）</strong>公钥，就会出现公钥错误。</p><p>以下是在安装 MySQL Community Server 时遇到的问题及解决方法的详细解释：</p><ol><li><p><strong>问题：</strong> 在尝试安装 MySQL Community Server 时，出现了错误消息，指示缺少 GPG 公钥。这是因为系统无法验证 MySQL 软件包的真实性，因此不允许安装。</p></li><li><p><strong>解决方案：</strong> 为了解决这个问题，需要获取并导入 MySQL 的 GPG 公钥，<strong>以便系统能够验证 MySQL 软件包的完整性和来源</strong>。您使用了以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br></pre></td></tr></table></figure><ul><li><code>rpm --import</code>：这是一个 RPM 包管理器的命令，用于导入 GPG 密钥。</li><li><code>https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</code>：这是 MySQL 2022 年的 GPG 密钥的 URL，它包含了用于验证 MySQL 软件包的数字签名。</li></ul></li><li><p>导入了 GPG 密钥后，您再次运行 <code>yum install -y mysql-community-server</code> 命令，这次成功安装了 MySQL Community Server。</p></li></ol><p>通过导入 GPG 密钥，告诉系统要信任来自 MySQL 官方仓库的软件包，并确保它们没有被篡改或损坏。这是一种常见的安全措施，用于确保您下载和安装的软件包是可信的。</p><p>如果将来遇到类似的 GPG 错误，可以考虑使用相同的方法导入适当的 GPG 密钥，以解决问题并安全地安装软件包。这有助于保护系统免受恶意软件包的威胁。</p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># systemctl start mysqld</span></span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># ps axj | grep mysqld | grep -v grep</span></span><br><span class="line">    1 11203 11202 11202 ?           -1 Sl      27   0:00 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># netstat -nltp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1378/sshd           </span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      11203/mysqld        </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1378/sshd  </span><br></pre></td></tr></table></figure><ol><li>使用 <code>systemctl start mysqld</code> 命令成功启动了 <strong>MySQL 服务器</strong>。这是启动 MySQL 服务器的<strong>标准命令</strong>。</li><li>使用 <code>netstat -nltp</code> 命令，您列出了所有当前<strong>正在侦听网络连接的服务器程序</strong>。结果显示 MySQL 服务器正在侦听端口 3306，这是 MySQL 默认的端口。此端口用于与 MySQL 数据库建立连接。</li></ol><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><blockquote><p>登陆方式有多种，此处笔者按照习惯推荐。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开mysql配置⽂件</span></span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line"><span class="comment"># 在最后⼀栏配置加⼊:skip-grant-tables选项,保存退出即可</span></span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># mysql</span></span><br><span class="line">ERROR 1045 (28000): Access denied <span class="keyword">for</span> user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> (using password: NO)</span><br><span class="line"><span class="comment"># 报错是因为此处需要重启服务</span></span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># systemctl restart mysqld</span></span><br><span class="line">[root@VM-16-4-centos MySQL]<span class="comment"># mysql</span></span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection <span class="built_in">id</span> is 2</span><br><span class="line">Server version: 5.7.43 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2023, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line"><span class="comment"># 到此为登陆成功！</span></span><br><span class="line">mysql&gt; quit</span><br><span class="line">Bye</span><br><span class="line"><span class="comment"># 输入quit按下回车即可退出</span></span><br></pre></td></tr></table></figure><blockquote><p><code>skip-grant-tables</code> 选项是 MySQL 的一个配置选项，它的作用是在启动 MySQL 数据库时跳过用户权限验证<strong>（跳过权限表）</strong>，允许用户在不提供有效凭据<strong>（用户名和密码）</strong>的情况下登录到 MySQL 数据库，会使 MySQL 数据库变得非常不安全。只有在必要时才应使用它，而且在使用完毕后应立即将其从 MySQL 配置中删除，并重新启用权限验证，以确保数据库的安全性。在生产环境中，应谨慎使用此选项。</p><p>此处只用来练习数据库，后续会出其他登陆方式教程。</p></blockquote><h2 id="设置开机启动（可选）"><a href="#设置开机启动（可选）" class="headerlink" title="设置开机启动（可选）"></a>设置开机启动（可选）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># systemctl enable mysqld</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># systemctl daemon-reload</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><ol><li><code>systemctl enable mysqld</code>：此命令会使 MySQL 服务在系统启动时自动启动。这意味着无需手动启动 MySQL 服务，它将在系统启动时自动运行。</li><li><code>systemctl daemon-reload</code>：此命令重新加载 systemd 系统管理守护程序的配置。通常，当您修改了 systemd 服务单元的配置文件时，需要运行此命令，以确保 systemd 重新读取并使用新的配置。</li></ol><blockquote><p>确保 MySQL 在系统启动时自动启动，并确保 systemd 使用最新的配置信息。</p></blockquote><h2 id="配置my-cnf"><a href="#配置my-cnf" class="headerlink" title="配置my.cnf"></a>配置<code>my.cnf</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-4-centos ~]<span class="comment"># vim /etc/my.cnf</span></span><br><span class="line"><span class="comment"># 加入下面三行配置</span></span><br><span class="line">+ port=3306</span><br><span class="line">+ datadir=/var/lib/mysql</span><br><span class="line">+ socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span></span><br><span class="line">symbolic-links=0</span><br><span class="line"></span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">skip-grant-tables</span><br><span class="line"><span class="comment"># 配置好之后重新启动服务即可</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># systemctl restart mysqld</span></span><br><span class="line">[root@VM-16-4-centos ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><ol><li><code>port=3306</code>：此选项指定 <strong>MySQL 服务器监听的端口号</strong>。默认情况下，MySQL 使用端口 3306 进行通信，因此这一行表示 MySQL 将在 3306 端口上侦听连接请求。</li><li><code>datadir=/var/lib/mysql</code>：这是 MySQL 数据目录的路径。MySQL 将存储数据库文件和相关数据在此目录中。</li><li><code>socket=/var/lib/mysql/mysql.sock</code>：MySQL 服务器套接字文件的路径。套接字文件用于本地连接到 MySQL 服务器。这里指定了 MySQL 套接字的位置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『STL』string详解</title>
      <link href="/2023/09/18/%E3%80%8ESTL%E3%80%8Fstring%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/09/18/%E3%80%8ESTL%E3%80%8Fstring%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h1><ul><li>C++98</li></ul><div class="table-container"><table><thead><tr><th style="text-align:right">default (1)</th><th><code>string();</code></th></tr></thead><tbody><tr><td style="text-align:right">copy (2)</td><td><code>string (const string&amp; str);</code></td></tr><tr><td style="text-align:right">substring (3)</td><td><code>string (const string&amp; str, size_t pos, size_t len = npos);</code></td></tr><tr><td style="text-align:right">from c-string (4)</td><td><code>string (const char* s);</code></td></tr><tr><td style="text-align:right">from sequence (5)</td><td><code>string (const char* s, size_t n);</code></td></tr><tr><td style="text-align:right">fill (6)</td><td><code>string (size_t n, char c);</code></td></tr><tr><td style="text-align:right">range (7)</td><td><code>template &lt;class InputIterator&gt;  string  (InputIterator first, InputIterator last);</code></td></tr></tbody></table></div><h2 id="Construct-string-object"><a href="#Construct-string-object" class="headerlink" title="Construct string object"></a>Construct string object</h2><blockquote><p><strong>Constructs a <a href="https://cplusplus.com/string">string</a> object, initializing its value depending on the constructor version used.</strong></p><p>构造一个字符串对象，根据使用的构造函数版本初始化其值。</p></blockquote><h3 id="1-empty-string-constructor-default-constructor"><a href="#1-empty-string-constructor-default-constructor" class="headerlink" title="(1) empty string constructor (default constructor)"></a>(1) empty string constructor (default constructor)</h3><blockquote><p><strong><code>default (1)  string();</code></strong></p><p><strong>Constructs an <a href="https://cplusplus.com/string::empty">empty</a> string, with a <a href="https://cplusplus.com/string::length">length</a> of zero characters.</strong></p><p>构造一个空字符串，长度为零个字符。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h3 id="2-copy-constructor"><a href="#2-copy-constructor" class="headerlink" title="(2) copy constructor"></a>(2) copy constructor</h3><blockquote><p><strong><code>copy (2)  string (const string&amp; str);</code></strong></p><p><strong>Constructs a copy of <em><code>str</code></em>.</strong></p><p>构造 字符串str 的副本。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str0</span> <span class="params">(<span class="string">&quot;Initial string&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//拷贝s0副本</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">str1</span><span class="params">(s0)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//Initial string</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h3 id="3-substring-constructor"><a href="#3-substring-constructor" class="headerlink" title="(3) substring constructor"></a>(3) substring constructor</h3><blockquote><p><strong><code>substring (3)  string (const string&amp; str, size_t pos, size_t len = npos);</code></strong></p><p><strong>Copies the portion of <em>str</em> that begins at the character position <em>pos</em> and spans <em>len</em> characters (or until the end of <em>str</em>, if either <em>str</em> is too short or if <em>len</em> is <a href="https://cplusplus.com/string::npos">string::npos</a>).</strong></p><p>复制 str 中从字符位置 pos 开始并跨越 len 个字符的部分（或者直到 str 的末尾，如果 str 太短或 len 是 string::npos）。</p><p>str太短指的是len值超过pos后字符个数（含pos位置）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str0</span><span class="params">(<span class="string">&quot;Initial string&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从pos（2）开始取5个字符构造str1(len == 5)</span></span><br><span class="line">    <span class="function">std::string <span class="title">str1</span><span class="params">(str0, <span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从pos（2）开始，取20个字符构造str2，看看结果如何（len==20）</span></span><br><span class="line">    <span class="function">std::string <span class="title">str2</span><span class="params">(str0, <span class="number">2</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只给pos（2），len的值使用缺省值，看看结果如何(len == npos)</span></span><br><span class="line">    <span class="function">std::string <span class="title">str3</span><span class="params">(str0, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str0:&quot;</span> &lt;&lt; str0 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1:&quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2:&quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str3:&quot;</span> &lt;&lt; str3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//str0:Initial string</span></span><br><span class="line"><span class="comment">//str1:itial</span></span><br><span class="line"><span class="comment">//str2:itial string</span></span><br><span class="line"><span class="comment">//str3:itial string</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h3 id="4-from-c-string"><a href="#4-from-c-string" class="headerlink" title="(4) from c-string"></a>(4) from c-string</h3><blockquote><p><strong><code>from c-string (4)  string (const char* s);</code></strong></p><p><strong>Copies the null-terminated character sequence (C-string) pointed by <em>s</em>.</strong></p><p>复制指针s 指向的以空字符终止的字符序列（即C 字符串）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">//使用c字符串构造str</span></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(s)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//Hello World!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h3 id="5-from-buffer"><a href="#5-from-buffer" class="headerlink" title="(5) from buffer"></a>(5) from buffer</h3><blockquote><p><strong><code>from sequence (5)  string (const char* s, size_t n);</code></strong></p><p><strong>Copies the first <em>n</em> characters from the array of characters pointed by <em>s</em>.</strong></p><p>复制指针 s 指向的字符序列中的前 n 个字符。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n值为5，即字符串s前5个字符</span></span><br><span class="line">    <span class="function">std::string <span class="title">str1</span><span class="params">(s, <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时n值为15，超过字符串s有效字符长度</span></span><br><span class="line">    <span class="comment">//编译器有警告表明长度超过，看看结果如何</span></span><br><span class="line">    <span class="function">std::string <span class="title">str2</span><span class="params">(s, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1:&quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2:&quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果似乎有些奇怪，可以多多尝试探索一下编译器如何处理</span></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//str1:Hello</span></span><br><span class="line"><span class="comment">//str2:Hello World! str1: str2:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h3 id="6-fill-constructor"><a href="#6-fill-constructor" class="headerlink" title="(6) fill constructor"></a>(6) fill constructor</h3><blockquote><p><strong><code>fill (6)  string (size_t n, char c);</code></strong></p><p><strong>Fills the string with <em>n</em> consecutive copies of character <em>c</em>.</strong></p><p>用n个字符 c 填充字符串。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//ccccc</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h1 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a><strong>Capacity</strong></h1><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Return length of string</strong></p><p>Returns the length of the string, in terms of bytes.</p><p>This is the number of actual bytes that conform the contents of the <a href="https://cplusplus.com/string">string</a>, <strong>which is not necessarily equal to its storage <a href="https://cplusplus.com/string::capacity">capacity</a>.</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span> <span class="params">(<span class="string">&quot;Test string&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of str is &quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//The size of str is 11 bytes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Return length of string</strong></p><p>Returns the length of the string, in terms of bytes.</p><p>This is the number of actual bytes that conform the contents of the <a href="https://cplusplus.com/string">string</a>, <strong>which is not necessarily equal to its storage <a href="https://cplusplus.com/string::capacity">capacity</a>.</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span> <span class="params">(<span class="string">&quot;Test string&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of str is &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; <span class="string">&quot; bytes.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//The size of str is 11 bytes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h2 id="max-size"><a href="#max-size" class="headerlink" title="max_size"></a>max_size</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Return maximum size of string</strong></p><p><strong>Returns the maximum length the <a href="https://cplusplus.com/string">string</a> can reach.</strong></p><p>This is the maximum potential <a href="https://cplusplus.com/string::length">length</a> the string can reach due to known system or library implementation limitations, <strong>but the object is not guaranteed to be able to reach that length:</strong> it can still fail to allocate storage at any point before that length is reached.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span> <span class="params">(<span class="string">&quot;Test string&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;length: &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max_size: &quot;</span> &lt;&lt; str.<span class="built_in">max_size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//size: 11</span></span><br><span class="line"><span class="comment">//length: 11</span></span><br><span class="line"><span class="comment">//capacity: 15</span></span><br><span class="line"><span class="comment">//max_size: 4611686018427387903</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span> <span class="params">(<span class="type">size_t</span> n)</span></span>;<span class="function"><span class="type">void</span> <span class="title">resize</span> <span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Resize string</strong></p><p>Resizes the string to a <a href="https://cplusplus.com/string::length">length</a> of <em>n</em> characters.</p><p>If <em>n</em> is smaller than the current <a href="https://cplusplus.com/string::length">string length</a>, the current value is shortened to its first <em>n</em> character, removing the characters beyond the <em>n</em>th.</p><p>如果 n 小于当前字符串长度，则当前值将缩短为其前 n 个字符，并删除第 n 个之后的字符。</p><p>If <em>n</em> is greater than the current <a href="https://cplusplus.com/string::length">string length</a>, the current content is extended by inserting at the end as many characters as needed to reach a size of <em>n</em>. If <em>c</em> is specified, the new elements are initialized as copies of <em>c</em>, otherwise, they are <em>value-initialized characters</em> (null characters).</p><p>如果 n 大于当前字符串长度，则通过在末尾插入所需数量的字符来扩展当前内容，以达到 n 的大小。如果指定了 c，则新元素将初始化为 字符c ，否则，它们是值初始化字符（空字符）。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;I like to code in c&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始 str.size:&quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始 str.capacity:&quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> sz = str.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定字符</span></span><br><span class="line">    str.<span class="built_in">resize</span>(sz + <span class="number">2</span>, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;新增两个字符 str.size:&quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;新增两个字符 str.capacity:&quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认字符</span></span><br><span class="line">    str.<span class="built_in">resize</span>(<span class="number">14</span>);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;缩减 str.size:&quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;缩减 str.capacity:&quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//I like to code in c</span></span><br><span class="line"><span class="comment">//初始 str.size:19</span></span><br><span class="line"><span class="comment">//初始 str.capacity:19</span></span><br><span class="line"><span class="comment">//I like to code in c++</span></span><br><span class="line"><span class="comment">//新增两个字符 str.size:21</span></span><br><span class="line"><span class="comment">//新增两个字符 str.capacity:38</span></span><br><span class="line"><span class="comment">//I like to code</span></span><br><span class="line"><span class="comment">//缩减 str.size:14</span></span><br><span class="line"><span class="comment">//缩减 str.capacity:38</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><blockquote><p>当resize函数中n值小于当前size时，不会对其容量capacity造成影响。</p></blockquote><h2 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Return size of allocated storage</strong></p><p>Returns the size of the storage space currently allocated for the <a href="https://cplusplus.com/string">string</a>, <strong>expressed in terms of bytes.</strong></p><p><strong>This <em>capacity</em> is not necessarily equal to the <a href="https://cplusplus.com/string::length">string length</a>.</strong> It can be equal or greater, with the extra space allowing the object to optimize its operations when new characters are added to the <a href="https://cplusplus.com/string">string</a>.</p><p>Notice that this <em>capacity</em> does not suppose a limit on the <a href="https://cplusplus.com/string::length">length</a> of the <a href="https://cplusplus.com/string">string</a>. When this <em>capacity</em> is exhausted and more is needed, it is automatically expanded by the object (reallocating it storage space). The theoretical limit on the <a href="https://cplusplus.com/string::length">length</a> of a <a href="https://cplusplus.com/string">string</a> is given by member <a href="https://cplusplus.com/string::max_size">max_size</a>.</p><p>理论最大值由成员变量max_size给出，容量不够时自动扩容。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span> <span class="params">(<span class="string">&quot;Test string&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;length: &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;capacity: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max_size: &quot;</span> &lt;&lt; str.<span class="built_in">max_size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//size: 11</span></span><br><span class="line"><span class="comment">//length: 11</span></span><br><span class="line"><span class="comment">//capacity: 15</span></span><br><span class="line"><span class="comment">//max_size: 4611686018427387903</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h2 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span> <span class="params">(<span class="type">size_t</span> n = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Request a change in capacity</strong></p><p>Requests that the <a href="https://cplusplus.com/string::capacity">string capacity</a> be adapted to a planned change in <a href="https://cplusplus.com/string::size">size</a> to a <a href="https://cplusplus.com/string::length">length</a> of up to <em>n</em> characters.</p><p>If <em>n</em> is greater than the current <a href="https://cplusplus.com/string::capacity">string capacity</a>, the function causes the container to <strong>increase its <a href="https://cplusplus.com/string::capacity">capacity</a> to <em>n</em> characters (or greater).</strong></p><p>当n值大于此时capacity时，容量会扩容到n或者更大，具体根据编译器实现有所不同。</p><p>In all other cases, it is taken as a non-binding request to shrink the <a href="https://cplusplus.com/string::capacity">string capacity</a>: the container implementation is free to optimize otherwise and leave the <a href="https://cplusplus.com/string">string</a> with a <a href="https://cplusplus.com/string::capacity">capacity</a> greater than <em>n</em>.</p><p>似乎用它来缩容时并不起作用。</p><p>This function has no effect on the <a href="https://cplusplus.com/string::length">string length</a> and cannot alter its content.</p><p>该函数对字符串长度没有影响，也不能改变其内容。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">reserve</span>(<span class="number">30</span>);</span><br><span class="line">    std::cout &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//15</span></span><br><span class="line"><span class="comment">//30</span></span><br><span class="line"><span class="comment">//30</span></span><br><span class="line"><span class="comment">//Hello World!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Clear string</strong></p><p>Erases the contents of the <a href="https://cplusplus.com/string">string</a>, which becomes an <a href="https://cplusplus.com/string::empty"><strong>empty string</strong></a> (with a <a href="https://cplusplus.com/string::length">length</a> of <code>0</code> characters).</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str.capacity&quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str.size&quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str.capacity&quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str.size&quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//str.capacity15</span></span><br><span class="line"><span class="comment">//str.size12</span></span><br><span class="line"><span class="comment">//str.capacity15</span></span><br><span class="line"><span class="comment">//str.size0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h2 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Test if string is empty</strong></p><p>Returns whether the <a href="https://cplusplus.com/string">string</a> is empty (i.e. whether its <a href="https://cplusplus.com/string::length">length</a> is <code>0</code>).</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line">    std::string str2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; str1.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; str2.<span class="built_in">empty</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//E:\DataStructure\StringTest\cmake-build-debug\StringTest.exe</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
